module.exports = [
"[project]/node_modules/hono/dist/adapter/vercel/handler.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/adapter/vercel/handler.ts
__turbopack_context__.s([
    "handle",
    ()=>handle
]);
var handle = (app)=>(req)=>{
        return app.fetch(req);
    };
;
}),
"[project]/node_modules/hono/dist/adapter/vercel/conninfo.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/adapter/vercel/conninfo.ts
__turbopack_context__.s([
    "getConnInfo",
    ()=>getConnInfo
]);
var getConnInfo = (c)=>({
        remote: {
            address: c.req.header("x-real-ip")
        }
    });
;
}),
"[project]/node_modules/hono/dist/adapter/vercel/index.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

// src/adapter/vercel/index.ts
__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$adapter$2f$vercel$2f$handler$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/adapter/vercel/handler.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$adapter$2f$vercel$2f$conninfo$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/adapter/vercel/conninfo.js [app-route] (ecmascript)");
;
;
;
}),
"[project]/node_modules/hono/dist/compose.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/compose.ts
__turbopack_context__.s([
    "compose",
    ()=>compose
]);
var compose = (middleware, onError, onNotFound)=>{
    return (context, next)=>{
        let index = -1;
        return dispatch(0);
        //TURBOPACK unreachable
        ;
        async function dispatch(i) {
            if (i <= index) {
                throw new Error("next() called multiple times");
            }
            index = i;
            let res;
            let isError = false;
            let handler;
            if (middleware[i]) {
                handler = middleware[i][0][0];
                context.req.routeIndex = i;
            } else {
                handler = i === middleware.length && next || void 0;
            }
            if (handler) {
                try {
                    res = await handler(context, ()=>dispatch(i + 1));
                } catch (err) {
                    if (err instanceof Error && onError) {
                        context.error = err;
                        res = await onError(err, context);
                        isError = true;
                    } else {
                        throw err;
                    }
                }
            } else {
                if (context.finalized === false && onNotFound) {
                    res = await onNotFound(context);
                }
            }
            if (res && (context.finalized === false || isError)) {
                context.res = res;
            }
            return context;
        }
    };
};
;
}),
"[project]/node_modules/hono/dist/http-exception.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/http-exception.ts
__turbopack_context__.s([
    "HTTPException",
    ()=>HTTPException
]);
var HTTPException = class extends Error {
    res;
    status;
    constructor(status = 500, options){
        super(options?.message, {
            cause: options?.cause
        });
        this.res = options?.res;
        this.status = status;
    }
    getResponse() {
        if (this.res) {
            const newResponse = new Response(this.res.body, {
                status: this.status,
                headers: this.res.headers
            });
            return newResponse;
        }
        return new Response(this.message, {
            status: this.status
        });
    }
};
;
}),
"[project]/node_modules/hono/dist/request/constants.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/request/constants.ts
__turbopack_context__.s([
    "GET_MATCH_RESULT",
    ()=>GET_MATCH_RESULT
]);
var GET_MATCH_RESULT = Symbol();
;
}),
"[project]/node_modules/hono/dist/utils/body.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/utils/body.ts
__turbopack_context__.s([
    "parseBody",
    ()=>parseBody
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$request$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/request.js [app-route] (ecmascript)");
;
var parseBody = async (request, options = /* @__PURE__ */ Object.create(null))=>{
    const { all = false, dot = false } = options;
    const headers = request instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$request$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HonoRequest"] ? request.raw.headers : request.headers;
    const contentType = headers.get("Content-Type");
    if (contentType?.startsWith("multipart/form-data") || contentType?.startsWith("application/x-www-form-urlencoded")) {
        return parseFormData(request, {
            all,
            dot
        });
    }
    return {};
};
async function parseFormData(request, options) {
    const formData = await request.formData();
    if (formData) {
        return convertFormDataToBodyData(formData, options);
    }
    return {};
}
function convertFormDataToBodyData(formData, options) {
    const form = /* @__PURE__ */ Object.create(null);
    formData.forEach((value, key)=>{
        const shouldParseAllValues = options.all || key.endsWith("[]");
        if (!shouldParseAllValues) {
            form[key] = value;
        } else {
            handleParsingAllValues(form, key, value);
        }
    });
    if (options.dot) {
        Object.entries(form).forEach(([key, value])=>{
            const shouldParseDotValues = key.includes(".");
            if (shouldParseDotValues) {
                handleParsingNestedValues(form, key, value);
                delete form[key];
            }
        });
    }
    return form;
}
var handleParsingAllValues = (form, key, value)=>{
    if (form[key] !== void 0) {
        if (Array.isArray(form[key])) {
            ;
            form[key].push(value);
        } else {
            form[key] = [
                form[key],
                value
            ];
        }
    } else {
        if (!key.endsWith("[]")) {
            form[key] = value;
        } else {
            form[key] = [
                value
            ];
        }
    }
};
var handleParsingNestedValues = (form, key, value)=>{
    let nestedForm = form;
    const keys = key.split(".");
    keys.forEach((key2, index)=>{
        if (index === keys.length - 1) {
            nestedForm[key2] = value;
        } else {
            if (!nestedForm[key2] || typeof nestedForm[key2] !== "object" || Array.isArray(nestedForm[key2]) || nestedForm[key2] instanceof File) {
                nestedForm[key2] = /* @__PURE__ */ Object.create(null);
            }
            nestedForm = nestedForm[key2];
        }
    });
};
;
}),
"[project]/node_modules/hono/dist/utils/url.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/utils/url.ts
__turbopack_context__.s([
    "checkOptionalParameter",
    ()=>checkOptionalParameter,
    "decodeURIComponent_",
    ()=>decodeURIComponent_,
    "getPath",
    ()=>getPath,
    "getPathNoStrict",
    ()=>getPathNoStrict,
    "getPattern",
    ()=>getPattern,
    "getQueryParam",
    ()=>getQueryParam,
    "getQueryParams",
    ()=>getQueryParams,
    "getQueryStrings",
    ()=>getQueryStrings,
    "mergePath",
    ()=>mergePath,
    "splitPath",
    ()=>splitPath,
    "splitRoutingPath",
    ()=>splitRoutingPath,
    "tryDecode",
    ()=>tryDecode
]);
var splitPath = (path)=>{
    const paths = path.split("/");
    if (paths[0] === "") {
        paths.shift();
    }
    return paths;
};
var splitRoutingPath = (routePath)=>{
    const { groups, path } = extractGroupsFromPath(routePath);
    const paths = splitPath(path);
    return replaceGroupMarks(paths, groups);
};
var extractGroupsFromPath = (path)=>{
    const groups = [];
    path = path.replace(/\{[^}]+\}/g, (match, index)=>{
        const mark = `@${index}`;
        groups.push([
            mark,
            match
        ]);
        return mark;
    });
    return {
        groups,
        path
    };
};
var replaceGroupMarks = (paths, groups)=>{
    for(let i = groups.length - 1; i >= 0; i--){
        const [mark] = groups[i];
        for(let j = paths.length - 1; j >= 0; j--){
            if (paths[j].includes(mark)) {
                paths[j] = paths[j].replace(mark, groups[i][1]);
                break;
            }
        }
    }
    return paths;
};
var patternCache = {};
var getPattern = (label, next)=>{
    if (label === "*") {
        return "*";
    }
    const match = label.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
    if (match) {
        const cacheKey = `${label}#${next}`;
        if (!patternCache[cacheKey]) {
            if (match[2]) {
                patternCache[cacheKey] = next && next[0] !== ":" && next[0] !== "*" ? [
                    cacheKey,
                    match[1],
                    new RegExp(`^${match[2]}(?=/${next})`)
                ] : [
                    label,
                    match[1],
                    new RegExp(`^${match[2]}$`)
                ];
            } else {
                patternCache[cacheKey] = [
                    label,
                    match[1],
                    true
                ];
            }
        }
        return patternCache[cacheKey];
    }
    return null;
};
var tryDecode = (str, decoder)=>{
    try {
        return decoder(str);
    } catch  {
        return str.replace(/(?:%[0-9A-Fa-f]{2})+/g, (match)=>{
            try {
                return decoder(match);
            } catch  {
                return match;
            }
        });
    }
};
var tryDecodeURI = (str)=>tryDecode(str, decodeURI);
var getPath = (request)=>{
    const url = request.url;
    const start = url.indexOf("/", url.indexOf(":") + 4);
    let i = start;
    for(; i < url.length; i++){
        const charCode = url.charCodeAt(i);
        if (charCode === 37) {
            const queryIndex = url.indexOf("?", i);
            const path = url.slice(start, queryIndex === -1 ? void 0 : queryIndex);
            return tryDecodeURI(path.includes("%25") ? path.replace(/%25/g, "%2525") : path);
        } else if (charCode === 63) {
            break;
        }
    }
    return url.slice(start, i);
};
var getQueryStrings = (url)=>{
    const queryIndex = url.indexOf("?", 8);
    return queryIndex === -1 ? "" : "?" + url.slice(queryIndex + 1);
};
var getPathNoStrict = (request)=>{
    const result = getPath(request);
    return result.length > 1 && result.at(-1) === "/" ? result.slice(0, -1) : result;
};
var mergePath = (base, sub, ...rest)=>{
    if (rest.length) {
        sub = mergePath(sub, ...rest);
    }
    return `${base?.[0] === "/" ? "" : "/"}${base}${sub === "/" ? "" : `${base?.at(-1) === "/" ? "" : "/"}${sub?.[0] === "/" ? sub.slice(1) : sub}`}`;
};
var checkOptionalParameter = (path)=>{
    if (path.charCodeAt(path.length - 1) !== 63 || !path.includes(":")) {
        return null;
    }
    const segments = path.split("/");
    const results = [];
    let basePath = "";
    segments.forEach((segment)=>{
        if (segment !== "" && !/\:/.test(segment)) {
            basePath += "/" + segment;
        } else if (/\:/.test(segment)) {
            if (/\?/.test(segment)) {
                if (results.length === 0 && basePath === "") {
                    results.push("/");
                } else {
                    results.push(basePath);
                }
                const optionalSegment = segment.replace("?", "");
                basePath += "/" + optionalSegment;
                results.push(basePath);
            } else {
                basePath += "/" + segment;
            }
        }
    });
    return results.filter((v, i, a)=>a.indexOf(v) === i);
};
var _decodeURI = (value)=>{
    if (!/[%+]/.test(value)) {
        return value;
    }
    if (value.indexOf("+") !== -1) {
        value = value.replace(/\+/g, " ");
    }
    return value.indexOf("%") !== -1 ? tryDecode(value, decodeURIComponent_) : value;
};
var _getQueryParam = (url, key, multiple)=>{
    let encoded;
    if (!multiple && key && !/[%+]/.test(key)) {
        let keyIndex2 = url.indexOf("?", 8);
        if (keyIndex2 === -1) {
            return void 0;
        }
        if (!url.startsWith(key, keyIndex2 + 1)) {
            keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);
        }
        while(keyIndex2 !== -1){
            const trailingKeyCode = url.charCodeAt(keyIndex2 + key.length + 1);
            if (trailingKeyCode === 61) {
                const valueIndex = keyIndex2 + key.length + 2;
                const endIndex = url.indexOf("&", valueIndex);
                return _decodeURI(url.slice(valueIndex, endIndex === -1 ? void 0 : endIndex));
            } else if (trailingKeyCode == 38 || isNaN(trailingKeyCode)) {
                return "";
            }
            keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);
        }
        encoded = /[%+]/.test(url);
        if (!encoded) {
            return void 0;
        }
    }
    const results = {};
    encoded ??= /[%+]/.test(url);
    let keyIndex = url.indexOf("?", 8);
    while(keyIndex !== -1){
        const nextKeyIndex = url.indexOf("&", keyIndex + 1);
        let valueIndex = url.indexOf("=", keyIndex);
        if (valueIndex > nextKeyIndex && nextKeyIndex !== -1) {
            valueIndex = -1;
        }
        let name = url.slice(keyIndex + 1, valueIndex === -1 ? nextKeyIndex === -1 ? void 0 : nextKeyIndex : valueIndex);
        if (encoded) {
            name = _decodeURI(name);
        }
        keyIndex = nextKeyIndex;
        if (name === "") {
            continue;
        }
        let value;
        if (valueIndex === -1) {
            value = "";
        } else {
            value = url.slice(valueIndex + 1, nextKeyIndex === -1 ? void 0 : nextKeyIndex);
            if (encoded) {
                value = _decodeURI(value);
            }
        }
        if (multiple) {
            if (!(results[name] && Array.isArray(results[name]))) {
                results[name] = [];
            }
            ;
            results[name].push(value);
        } else {
            results[name] ??= value;
        }
    }
    return key ? results[key] : results;
};
var getQueryParam = _getQueryParam;
var getQueryParams = (url, key)=>{
    return _getQueryParam(url, key, true);
};
var decodeURIComponent_ = decodeURIComponent;
;
}),
"[project]/node_modules/hono/dist/request.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/request.ts
__turbopack_context__.s([
    "HonoRequest",
    ()=>HonoRequest,
    "cloneRawRequest",
    ()=>cloneRawRequest
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$http$2d$exception$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/http-exception.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$request$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/request/constants.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$body$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/utils/body.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$url$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/utils/url.js [app-route] (ecmascript)");
;
;
;
;
var tryDecodeURIComponent = (str)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$url$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tryDecode"])(str, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$url$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["decodeURIComponent_"]);
var HonoRequest = class {
    raw;
    #validatedData;
    #matchResult;
    routeIndex = 0;
    path;
    bodyCache = {};
    constructor(request, path = "/", matchResult = [
        []
    ]){
        this.raw = request;
        this.path = path;
        this.#matchResult = matchResult;
        this.#validatedData = {};
    }
    param(key) {
        return key ? this.#getDecodedParam(key) : this.#getAllDecodedParams();
    }
    #getDecodedParam(key) {
        const paramKey = this.#matchResult[0][this.routeIndex][1][key];
        const param = this.#getParamValue(paramKey);
        return param && /\%/.test(param) ? tryDecodeURIComponent(param) : param;
    }
    #getAllDecodedParams() {
        const decoded = {};
        const keys = Object.keys(this.#matchResult[0][this.routeIndex][1]);
        for (const key of keys){
            const value = this.#getParamValue(this.#matchResult[0][this.routeIndex][1][key]);
            if (value !== void 0) {
                decoded[key] = /\%/.test(value) ? tryDecodeURIComponent(value) : value;
            }
        }
        return decoded;
    }
    #getParamValue(paramKey) {
        return this.#matchResult[1] ? this.#matchResult[1][paramKey] : paramKey;
    }
    query(key) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$url$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getQueryParam"])(this.url, key);
    }
    queries(key) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$url$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getQueryParams"])(this.url, key);
    }
    header(name) {
        if (name) {
            return this.raw.headers.get(name) ?? void 0;
        }
        const headerData = {};
        this.raw.headers.forEach((value, key)=>{
            headerData[key] = value;
        });
        return headerData;
    }
    async parseBody(options) {
        return this.bodyCache.parsedBody ??= await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$body$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseBody"])(this, options);
    }
    #cachedBody = (key)=>{
        const { bodyCache, raw } = this;
        const cachedBody = bodyCache[key];
        if (cachedBody) {
            return cachedBody;
        }
        const anyCachedKey = Object.keys(bodyCache)[0];
        if (anyCachedKey) {
            return bodyCache[anyCachedKey].then((body)=>{
                if (anyCachedKey === "json") {
                    body = JSON.stringify(body);
                }
                return new Response(body)[key]();
            });
        }
        return bodyCache[key] = raw[key]();
    };
    json() {
        return this.#cachedBody("text").then((text)=>JSON.parse(text));
    }
    text() {
        return this.#cachedBody("text");
    }
    arrayBuffer() {
        return this.#cachedBody("arrayBuffer");
    }
    blob() {
        return this.#cachedBody("blob");
    }
    formData() {
        return this.#cachedBody("formData");
    }
    addValidatedData(target, data) {
        this.#validatedData[target] = data;
    }
    valid(target) {
        return this.#validatedData[target];
    }
    get url() {
        return this.raw.url;
    }
    get method() {
        return this.raw.method;
    }
    get [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$request$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GET_MATCH_RESULT"]]() {
        return this.#matchResult;
    }
    get matchedRoutes() {
        return this.#matchResult[0].map(([[, route]])=>route);
    }
    get routePath() {
        return this.#matchResult[0].map(([[, route]])=>route)[this.routeIndex].path;
    }
};
var cloneRawRequest = async (req)=>{
    if (!req.raw.bodyUsed) {
        return req.raw.clone();
    }
    const cacheKey = Object.keys(req.bodyCache)[0];
    if (!cacheKey) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$http$2d$exception$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HTTPException"](500, {
            message: "Cannot clone request: body was already consumed and not cached. Please use HonoRequest methods (e.g., req.json(), req.text()) instead of consuming req.raw directly."
        });
    }
    const requestInit = {
        body: await req[cacheKey](),
        cache: req.raw.cache,
        credentials: req.raw.credentials,
        headers: req.header(),
        integrity: req.raw.integrity,
        keepalive: req.raw.keepalive,
        method: req.method,
        mode: req.raw.mode,
        redirect: req.raw.redirect,
        referrer: req.raw.referrer,
        referrerPolicy: req.raw.referrerPolicy,
        signal: req.raw.signal
    };
    return new Request(req.url, requestInit);
};
;
}),
"[project]/node_modules/hono/dist/utils/html.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/utils/html.ts
__turbopack_context__.s([
    "HtmlEscapedCallbackPhase",
    ()=>HtmlEscapedCallbackPhase,
    "escapeToBuffer",
    ()=>escapeToBuffer,
    "raw",
    ()=>raw,
    "resolveCallback",
    ()=>resolveCallback,
    "resolveCallbackSync",
    ()=>resolveCallbackSync,
    "stringBufferToString",
    ()=>stringBufferToString
]);
var HtmlEscapedCallbackPhase = {
    Stringify: 1,
    BeforeStream: 2,
    Stream: 3
};
var raw = (value, callbacks)=>{
    const escapedString = new String(value);
    escapedString.isEscaped = true;
    escapedString.callbacks = callbacks;
    return escapedString;
};
var escapeRe = /[&<>'"]/;
var stringBufferToString = async (buffer, callbacks)=>{
    let str = "";
    callbacks ||= [];
    const resolvedBuffer = await Promise.all(buffer);
    for(let i = resolvedBuffer.length - 1;; i--){
        str += resolvedBuffer[i];
        i--;
        if (i < 0) {
            break;
        }
        let r = resolvedBuffer[i];
        if (typeof r === "object") {
            callbacks.push(...r.callbacks || []);
        }
        const isEscaped = r.isEscaped;
        r = await (typeof r === "object" ? r.toString() : r);
        if (typeof r === "object") {
            callbacks.push(...r.callbacks || []);
        }
        if (r.isEscaped ?? isEscaped) {
            str += r;
        } else {
            const buf = [
                str
            ];
            escapeToBuffer(r, buf);
            str = buf[0];
        }
    }
    return raw(str, callbacks);
};
var escapeToBuffer = (str, buffer)=>{
    const match = str.search(escapeRe);
    if (match === -1) {
        buffer[0] += str;
        return;
    }
    let escape;
    let index;
    let lastIndex = 0;
    for(index = match; index < str.length; index++){
        switch(str.charCodeAt(index)){
            case 34:
                escape = "&quot;";
                break;
            case 39:
                escape = "&#39;";
                break;
            case 38:
                escape = "&amp;";
                break;
            case 60:
                escape = "&lt;";
                break;
            case 62:
                escape = "&gt;";
                break;
            default:
                continue;
        }
        buffer[0] += str.substring(lastIndex, index) + escape;
        lastIndex = index + 1;
    }
    buffer[0] += str.substring(lastIndex, index);
};
var resolveCallbackSync = (str)=>{
    const callbacks = str.callbacks;
    if (!callbacks?.length) {
        return str;
    }
    const buffer = [
        str
    ];
    const context = {};
    callbacks.forEach((c)=>c({
            phase: HtmlEscapedCallbackPhase.Stringify,
            buffer,
            context
        }));
    return buffer[0];
};
var resolveCallback = async (str, phase, preserveCallbacks, context, buffer)=>{
    if (typeof str === "object" && !(str instanceof String)) {
        if (!(str instanceof Promise)) {
            str = str.toString();
        }
        if (str instanceof Promise) {
            str = await str;
        }
    }
    const callbacks = str.callbacks;
    if (!callbacks?.length) {
        return Promise.resolve(str);
    }
    if (buffer) {
        buffer[0] += str;
    } else {
        buffer = [
            str
        ];
    }
    const resStr = Promise.all(callbacks.map((c)=>c({
            phase,
            buffer,
            context
        }))).then((res)=>Promise.all(res.filter(Boolean).map((str2)=>resolveCallback(str2, phase, false, context, buffer))).then(()=>buffer[0]));
    if (preserveCallbacks) {
        return raw(await resStr, callbacks);
    } else {
        return resStr;
    }
};
;
}),
"[project]/node_modules/hono/dist/context.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/context.ts
__turbopack_context__.s([
    "Context",
    ()=>Context,
    "TEXT_PLAIN",
    ()=>TEXT_PLAIN
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$request$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/request.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$html$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/utils/html.js [app-route] (ecmascript)");
;
;
var TEXT_PLAIN = "text/plain; charset=UTF-8";
var setDefaultContentType = (contentType, headers)=>{
    return {
        "Content-Type": contentType,
        ...headers
    };
};
var Context = class {
    #rawRequest;
    #req;
    env = {};
    #var;
    finalized = false;
    error;
    #status;
    #executionCtx;
    #res;
    #layout;
    #renderer;
    #notFoundHandler;
    #preparedHeaders;
    #matchResult;
    #path;
    constructor(req, options){
        this.#rawRequest = req;
        if (options) {
            this.#executionCtx = options.executionCtx;
            this.env = options.env;
            this.#notFoundHandler = options.notFoundHandler;
            this.#path = options.path;
            this.#matchResult = options.matchResult;
        }
    }
    get req() {
        this.#req ??= new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$request$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HonoRequest"](this.#rawRequest, this.#path, this.#matchResult);
        return this.#req;
    }
    get event() {
        if (this.#executionCtx && "respondWith" in this.#executionCtx) {
            return this.#executionCtx;
        } else {
            throw Error("This context has no FetchEvent");
        }
    }
    get executionCtx() {
        if (this.#executionCtx) {
            return this.#executionCtx;
        } else {
            throw Error("This context has no ExecutionContext");
        }
    }
    get res() {
        return this.#res ||= new Response(null, {
            headers: this.#preparedHeaders ??= new Headers()
        });
    }
    set res(_res) {
        if (this.#res && _res) {
            _res = new Response(_res.body, _res);
            for (const [k, v] of this.#res.headers.entries()){
                if (k === "content-type") {
                    continue;
                }
                if (k === "set-cookie") {
                    const cookies = this.#res.headers.getSetCookie();
                    _res.headers.delete("set-cookie");
                    for (const cookie of cookies){
                        _res.headers.append("set-cookie", cookie);
                    }
                } else {
                    _res.headers.set(k, v);
                }
            }
        }
        this.#res = _res;
        this.finalized = true;
    }
    render = (...args)=>{
        this.#renderer ??= (content)=>this.html(content);
        return this.#renderer(...args);
    };
    setLayout = (layout)=>this.#layout = layout;
    getLayout = ()=>this.#layout;
    setRenderer = (renderer)=>{
        this.#renderer = renderer;
    };
    header = (name, value, options)=>{
        if (this.finalized) {
            this.#res = new Response(this.#res.body, this.#res);
        }
        const headers = this.#res ? this.#res.headers : this.#preparedHeaders ??= new Headers();
        if (value === void 0) {
            headers.delete(name);
        } else if (options?.append) {
            headers.append(name, value);
        } else {
            headers.set(name, value);
        }
    };
    status = (status)=>{
        this.#status = status;
    };
    set = (key, value)=>{
        this.#var ??= /* @__PURE__ */ new Map();
        this.#var.set(key, value);
    };
    get = (key)=>{
        return this.#var ? this.#var.get(key) : void 0;
    };
    get var() {
        if (!this.#var) {
            return {};
        }
        return Object.fromEntries(this.#var);
    }
    #newResponse(data, arg, headers) {
        const responseHeaders = this.#res ? new Headers(this.#res.headers) : this.#preparedHeaders ?? new Headers();
        if (typeof arg === "object" && "headers" in arg) {
            const argHeaders = arg.headers instanceof Headers ? arg.headers : new Headers(arg.headers);
            for (const [key, value] of argHeaders){
                if (key.toLowerCase() === "set-cookie") {
                    responseHeaders.append(key, value);
                } else {
                    responseHeaders.set(key, value);
                }
            }
        }
        if (headers) {
            for (const [k, v] of Object.entries(headers)){
                if (typeof v === "string") {
                    responseHeaders.set(k, v);
                } else {
                    responseHeaders.delete(k);
                    for (const v2 of v){
                        responseHeaders.append(k, v2);
                    }
                }
            }
        }
        const status = typeof arg === "number" ? arg : arg?.status ?? this.#status;
        return new Response(data, {
            status,
            headers: responseHeaders
        });
    }
    newResponse = (...args)=>this.#newResponse(...args);
    body = (data, arg, headers)=>this.#newResponse(data, arg, headers);
    text = (text, arg, headers)=>{
        return !this.#preparedHeaders && !this.#status && !arg && !headers && !this.finalized ? new Response(text) : this.#newResponse(text, arg, setDefaultContentType(TEXT_PLAIN, headers));
    };
    json = (object, arg, headers)=>{
        return this.#newResponse(JSON.stringify(object), arg, setDefaultContentType("application/json", headers));
    };
    html = (html, arg, headers)=>{
        const res = (html2)=>this.#newResponse(html2, arg, setDefaultContentType("text/html; charset=UTF-8", headers));
        return typeof html === "object" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$html$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["resolveCallback"])(html, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$html$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HtmlEscapedCallbackPhase"].Stringify, false, {}).then(res) : res(html);
    };
    redirect = (location, status)=>{
        const locationString = String(location);
        this.header("Location", !/[^\x00-\xFF]/.test(locationString) ? locationString : encodeURI(locationString));
        return this.newResponse(null, status ?? 302);
    };
    notFound = ()=>{
        this.#notFoundHandler ??= ()=>new Response();
        return this.#notFoundHandler(this);
    };
};
;
}),
"[project]/node_modules/hono/dist/router.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/router.ts
__turbopack_context__.s([
    "MESSAGE_MATCHER_IS_ALREADY_BUILT",
    ()=>MESSAGE_MATCHER_IS_ALREADY_BUILT,
    "METHODS",
    ()=>METHODS,
    "METHOD_NAME_ALL",
    ()=>METHOD_NAME_ALL,
    "METHOD_NAME_ALL_LOWERCASE",
    ()=>METHOD_NAME_ALL_LOWERCASE,
    "UnsupportedPathError",
    ()=>UnsupportedPathError
]);
var METHOD_NAME_ALL = "ALL";
var METHOD_NAME_ALL_LOWERCASE = "all";
var METHODS = [
    "get",
    "post",
    "put",
    "delete",
    "options",
    "patch"
];
var MESSAGE_MATCHER_IS_ALREADY_BUILT = "Can not add a route since the matcher is already built.";
var UnsupportedPathError = class extends Error {
};
;
}),
"[project]/node_modules/hono/dist/utils/constants.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/utils/constants.ts
__turbopack_context__.s([
    "COMPOSED_HANDLER",
    ()=>COMPOSED_HANDLER
]);
var COMPOSED_HANDLER = "__COMPOSED_HANDLER";
;
}),
"[project]/node_modules/hono/dist/hono-base.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/hono-base.ts
__turbopack_context__.s([
    "HonoBase",
    ()=>Hono
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$compose$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/compose.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$context$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/context.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/router.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/utils/constants.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$url$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/utils/url.js [app-route] (ecmascript)");
;
;
;
;
;
var notFoundHandler = (c)=>{
    return c.text("404 Not Found", 404);
};
var errorHandler = (err, c)=>{
    if ("getResponse" in err) {
        const res = err.getResponse();
        return c.newResponse(res.body, res);
    }
    console.error(err);
    return c.text("Internal Server Error", 500);
};
var Hono = class {
    get;
    post;
    put;
    delete;
    options;
    patch;
    all;
    on;
    use;
    router;
    getPath;
    _basePath = "/";
    #path = "/";
    routes = [];
    constructor(options = {}){
        const allMethods = [
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["METHODS"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["METHOD_NAME_ALL_LOWERCASE"]
        ];
        allMethods.forEach((method)=>{
            this[method] = (args1, ...args)=>{
                if (typeof args1 === "string") {
                    this.#path = args1;
                } else {
                    this.#addRoute(method, this.#path, args1);
                }
                args.forEach((handler)=>{
                    this.#addRoute(method, this.#path, handler);
                });
                return this;
            };
        });
        this.on = (method, path, ...handlers)=>{
            for (const p of [
                path
            ].flat()){
                this.#path = p;
                for (const m of [
                    method
                ].flat()){
                    handlers.map((handler)=>{
                        this.#addRoute(m.toUpperCase(), this.#path, handler);
                    });
                }
            }
            return this;
        };
        this.use = (arg1, ...handlers)=>{
            if (typeof arg1 === "string") {
                this.#path = arg1;
            } else {
                this.#path = "*";
                handlers.unshift(arg1);
            }
            handlers.forEach((handler)=>{
                this.#addRoute(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["METHOD_NAME_ALL"], this.#path, handler);
            });
            return this;
        };
        const { strict, ...optionsWithoutStrict } = options;
        Object.assign(this, optionsWithoutStrict);
        this.getPath = strict ?? true ? options.getPath ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$url$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getPath"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$url$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getPathNoStrict"];
    }
    #clone() {
        const clone = new Hono({
            router: this.router,
            getPath: this.getPath
        });
        clone.errorHandler = this.errorHandler;
        clone.#notFoundHandler = this.#notFoundHandler;
        clone.routes = this.routes;
        return clone;
    }
    #notFoundHandler = notFoundHandler;
    errorHandler = errorHandler;
    route(path, app) {
        const subApp = this.basePath(path);
        app.routes.map((r)=>{
            let handler;
            if (app.errorHandler === errorHandler) {
                handler = r.handler;
            } else {
                handler = async (c, next)=>(await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$compose$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["compose"])([], app.errorHandler)(c, ()=>r.handler(c, next))).res;
                handler[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$constants$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["COMPOSED_HANDLER"]] = r.handler;
            }
            subApp.#addRoute(r.method, r.path, handler);
        });
        return this;
    }
    basePath(path) {
        const subApp = this.#clone();
        subApp._basePath = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$url$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["mergePath"])(this._basePath, path);
        return subApp;
    }
    onError = (handler)=>{
        this.errorHandler = handler;
        return this;
    };
    notFound = (handler)=>{
        this.#notFoundHandler = handler;
        return this;
    };
    mount(path, applicationHandler, options) {
        let replaceRequest;
        let optionHandler;
        if (options) {
            if (typeof options === "function") {
                optionHandler = options;
            } else {
                optionHandler = options.optionHandler;
                if (options.replaceRequest === false) {
                    replaceRequest = (request)=>request;
                } else {
                    replaceRequest = options.replaceRequest;
                }
            }
        }
        const getOptions = optionHandler ? (c)=>{
            const options2 = optionHandler(c);
            return Array.isArray(options2) ? options2 : [
                options2
            ];
        } : (c)=>{
            let executionContext = void 0;
            try {
                executionContext = c.executionCtx;
            } catch  {}
            return [
                c.env,
                executionContext
            ];
        };
        replaceRequest ||= (()=>{
            const mergedPath = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$url$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["mergePath"])(this._basePath, path);
            const pathPrefixLength = mergedPath === "/" ? 0 : mergedPath.length;
            return (request)=>{
                const url = new URL(request.url);
                url.pathname = url.pathname.slice(pathPrefixLength) || "/";
                return new Request(url, request);
            };
        })();
        const handler = async (c, next)=>{
            const res = await applicationHandler(replaceRequest(c.req.raw), ...getOptions(c));
            if (res) {
                return res;
            }
            await next();
        };
        this.#addRoute(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["METHOD_NAME_ALL"], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$url$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["mergePath"])(path, "*"), handler);
        return this;
    }
    #addRoute(method, path, handler) {
        method = method.toUpperCase();
        path = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$url$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["mergePath"])(this._basePath, path);
        const r = {
            basePath: this._basePath,
            path,
            method,
            handler
        };
        this.router.add(method, path, [
            handler,
            r
        ]);
        this.routes.push(r);
    }
    #handleError(err, c) {
        if (err instanceof Error) {
            return this.errorHandler(err, c);
        }
        throw err;
    }
    #dispatch(request, executionCtx, env, method) {
        if (method === "HEAD") {
            return (async ()=>new Response(null, await this.#dispatch(request, executionCtx, env, "GET")))();
        }
        const path = this.getPath(request, {
            env
        });
        const matchResult = this.router.match(method, path);
        const c = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$context$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Context"](request, {
            path,
            matchResult,
            env,
            executionCtx,
            notFoundHandler: this.#notFoundHandler
        });
        if (matchResult[0].length === 1) {
            let res;
            try {
                res = matchResult[0][0][0][0](c, async ()=>{
                    c.res = await this.#notFoundHandler(c);
                });
            } catch (err) {
                return this.#handleError(err, c);
            }
            return res instanceof Promise ? res.then((resolved)=>resolved || (c.finalized ? c.res : this.#notFoundHandler(c))).catch((err)=>this.#handleError(err, c)) : res ?? this.#notFoundHandler(c);
        }
        const composed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$compose$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["compose"])(matchResult[0], this.errorHandler, this.#notFoundHandler);
        return (async ()=>{
            try {
                const context = await composed(c);
                if (!context.finalized) {
                    throw new Error("Context is not finalized. Did you forget to return a Response object or `await next()`?");
                }
                return context.res;
            } catch (err) {
                return this.#handleError(err, c);
            }
        })();
    }
    fetch = (request, ...rest)=>{
        return this.#dispatch(request, rest[1], rest[0], request.method);
    };
    request = (input, requestInit, Env, executionCtx)=>{
        if (input instanceof Request) {
            return this.fetch(requestInit ? new Request(input, requestInit) : input, Env, executionCtx);
        }
        input = input.toString();
        return this.fetch(new Request(/^https?:\/\//.test(input) ? input : `http://localhost${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$url$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["mergePath"])("/", input)}`, requestInit), Env, executionCtx);
    };
    fire = ()=>{
        addEventListener("fetch", (event)=>{
            event.respondWith(this.#dispatch(event.request, event, void 0, event.request.method));
        });
    };
};
;
}),
"[project]/node_modules/hono/dist/router/reg-exp-router/matcher.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/router/reg-exp-router/matcher.ts
__turbopack_context__.s([
    "emptyParam",
    ()=>emptyParam,
    "match",
    ()=>match
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/router.js [app-route] (ecmascript)");
;
var emptyParam = [];
function match(method, path) {
    const matchers = this.buildAllMatchers();
    const match2 = (method2, path2)=>{
        const matcher = matchers[method2] || matchers[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["METHOD_NAME_ALL"]];
        const staticMatch = matcher[2][path2];
        if (staticMatch) {
            return staticMatch;
        }
        const match3 = path2.match(matcher[0]);
        if (!match3) {
            return [
                [],
                emptyParam
            ];
        }
        const index = match3.indexOf("", 1);
        return [
            matcher[1][index],
            match3
        ];
    };
    this.match = match2;
    return match2(method, path);
}
;
}),
"[project]/node_modules/hono/dist/router/reg-exp-router/node.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/router/reg-exp-router/node.ts
__turbopack_context__.s([
    "Node",
    ()=>Node,
    "PATH_ERROR",
    ()=>PATH_ERROR
]);
var LABEL_REG_EXP_STR = "[^/]+";
var ONLY_WILDCARD_REG_EXP_STR = ".*";
var TAIL_WILDCARD_REG_EXP_STR = "(?:|/.*)";
var PATH_ERROR = Symbol();
var regExpMetaChars = new Set(".\\+*[^]$()");
function compareKey(a, b) {
    if (a.length === 1) {
        return b.length === 1 ? a < b ? -1 : 1 : -1;
    }
    if (b.length === 1) {
        return 1;
    }
    if (a === ONLY_WILDCARD_REG_EXP_STR || a === TAIL_WILDCARD_REG_EXP_STR) {
        return 1;
    } else if (b === ONLY_WILDCARD_REG_EXP_STR || b === TAIL_WILDCARD_REG_EXP_STR) {
        return -1;
    }
    if (a === LABEL_REG_EXP_STR) {
        return 1;
    } else if (b === LABEL_REG_EXP_STR) {
        return -1;
    }
    return a.length === b.length ? a < b ? -1 : 1 : b.length - a.length;
}
var Node = class {
    #index;
    #varIndex;
    #children = /* @__PURE__ */ Object.create(null);
    insert(tokens, index, paramMap, context, pathErrorCheckOnly) {
        if (tokens.length === 0) {
            if (this.#index !== void 0) {
                throw PATH_ERROR;
            }
            if (pathErrorCheckOnly) {
                return;
            }
            this.#index = index;
            return;
        }
        const [token, ...restTokens] = tokens;
        const pattern = token === "*" ? restTokens.length === 0 ? [
            "",
            "",
            ONLY_WILDCARD_REG_EXP_STR
        ] : [
            "",
            "",
            LABEL_REG_EXP_STR
        ] : token === "/*" ? [
            "",
            "",
            TAIL_WILDCARD_REG_EXP_STR
        ] : token.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
        let node;
        if (pattern) {
            const name = pattern[1];
            let regexpStr = pattern[2] || LABEL_REG_EXP_STR;
            if (name && pattern[2]) {
                if (regexpStr === ".*") {
                    throw PATH_ERROR;
                }
                regexpStr = regexpStr.replace(/^\((?!\?:)(?=[^)]+\)$)/, "(?:");
                if (/\((?!\?:)/.test(regexpStr)) {
                    throw PATH_ERROR;
                }
            }
            node = this.#children[regexpStr];
            if (!node) {
                if (Object.keys(this.#children).some((k)=>k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR)) {
                    throw PATH_ERROR;
                }
                if (pathErrorCheckOnly) {
                    return;
                }
                node = this.#children[regexpStr] = new Node();
                if (name !== "") {
                    node.#varIndex = context.varIndex++;
                }
            }
            if (!pathErrorCheckOnly && name !== "") {
                paramMap.push([
                    name,
                    node.#varIndex
                ]);
            }
        } else {
            node = this.#children[token];
            if (!node) {
                if (Object.keys(this.#children).some((k)=>k.length > 1 && k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR)) {
                    throw PATH_ERROR;
                }
                if (pathErrorCheckOnly) {
                    return;
                }
                node = this.#children[token] = new Node();
            }
        }
        node.insert(restTokens, index, paramMap, context, pathErrorCheckOnly);
    }
    buildRegExpStr() {
        const childKeys = Object.keys(this.#children).sort(compareKey);
        const strList = childKeys.map((k)=>{
            const c = this.#children[k];
            return (typeof c.#varIndex === "number" ? `(${k})@${c.#varIndex}` : regExpMetaChars.has(k) ? `\\${k}` : k) + c.buildRegExpStr();
        });
        if (typeof this.#index === "number") {
            strList.unshift(`#${this.#index}`);
        }
        if (strList.length === 0) {
            return "";
        }
        if (strList.length === 1) {
            return strList[0];
        }
        return "(?:" + strList.join("|") + ")";
    }
};
;
}),
"[project]/node_modules/hono/dist/router/reg-exp-router/trie.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/router/reg-exp-router/trie.ts
__turbopack_context__.s([
    "Trie",
    ()=>Trie
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2f$reg$2d$exp$2d$router$2f$node$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/router/reg-exp-router/node.js [app-route] (ecmascript)");
;
var Trie = class {
    #context = {
        varIndex: 0
    };
    #root = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2f$reg$2d$exp$2d$router$2f$node$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Node"]();
    insert(path, index, pathErrorCheckOnly) {
        const paramAssoc = [];
        const groups = [];
        for(let i = 0;;){
            let replaced = false;
            path = path.replace(/\{[^}]+\}/g, (m)=>{
                const mark = `@\\${i}`;
                groups[i] = [
                    mark,
                    m
                ];
                i++;
                replaced = true;
                return mark;
            });
            if (!replaced) {
                break;
            }
        }
        const tokens = path.match(/(?::[^\/]+)|(?:\/\*$)|./g) || [];
        for(let i = groups.length - 1; i >= 0; i--){
            const [mark] = groups[i];
            for(let j = tokens.length - 1; j >= 0; j--){
                if (tokens[j].indexOf(mark) !== -1) {
                    tokens[j] = tokens[j].replace(mark, groups[i][1]);
                    break;
                }
            }
        }
        this.#root.insert(tokens, index, paramAssoc, this.#context, pathErrorCheckOnly);
        return paramAssoc;
    }
    buildRegExp() {
        let regexp = this.#root.buildRegExpStr();
        if (regexp === "") {
            return [
                /^$/,
                [],
                []
            ];
        }
        let captureIndex = 0;
        const indexReplacementMap = [];
        const paramReplacementMap = [];
        regexp = regexp.replace(/#(\d+)|@(\d+)|\.\*\$/g, (_, handlerIndex, paramIndex)=>{
            if (handlerIndex !== void 0) {
                indexReplacementMap[++captureIndex] = Number(handlerIndex);
                return "$()";
            }
            if (paramIndex !== void 0) {
                paramReplacementMap[Number(paramIndex)] = ++captureIndex;
                return "";
            }
            return "";
        });
        return [
            new RegExp(`^${regexp}`),
            indexReplacementMap,
            paramReplacementMap
        ];
    }
};
;
}),
"[project]/node_modules/hono/dist/router/reg-exp-router/router.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/router/reg-exp-router/router.ts
__turbopack_context__.s([
    "RegExpRouter",
    ()=>RegExpRouter
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/router.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$url$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/utils/url.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2f$reg$2d$exp$2d$router$2f$matcher$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/router/reg-exp-router/matcher.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2f$reg$2d$exp$2d$router$2f$node$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/router/reg-exp-router/node.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2f$reg$2d$exp$2d$router$2f$trie$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/router/reg-exp-router/trie.js [app-route] (ecmascript)");
;
;
;
;
;
var nullMatcher = [
    /^$/,
    [],
    /* @__PURE__ */ Object.create(null)
];
var wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
function buildWildcardRegExp(path) {
    return wildcardRegExpCache[path] ??= new RegExp(path === "*" ? "" : `^${path.replace(/\/\*$|([.\\+*[^\]$()])/g, (_, metaChar)=>metaChar ? `\\${metaChar}` : "(?:|/.*)")}$`);
}
function clearWildcardRegExpCache() {
    wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
}
function buildMatcherFromPreprocessedRoutes(routes) {
    const trie = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2f$reg$2d$exp$2d$router$2f$trie$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Trie"]();
    const handlerData = [];
    if (routes.length === 0) {
        return nullMatcher;
    }
    const routesWithStaticPathFlag = routes.map((route)=>[
            !/\*|\/:/.test(route[0]),
            ...route
        ]).sort(([isStaticA, pathA], [isStaticB, pathB])=>isStaticA ? 1 : isStaticB ? -1 : pathA.length - pathB.length);
    const staticMap = /* @__PURE__ */ Object.create(null);
    for(let i = 0, j = -1, len = routesWithStaticPathFlag.length; i < len; i++){
        const [pathErrorCheckOnly, path, handlers] = routesWithStaticPathFlag[i];
        if (pathErrorCheckOnly) {
            staticMap[path] = [
                handlers.map(([h])=>[
                        h,
                        /* @__PURE__ */ Object.create(null)
                    ]),
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2f$reg$2d$exp$2d$router$2f$matcher$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["emptyParam"]
            ];
        } else {
            j++;
        }
        let paramAssoc;
        try {
            paramAssoc = trie.insert(path, j, pathErrorCheckOnly);
        } catch (e) {
            throw e === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2f$reg$2d$exp$2d$router$2f$node$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PATH_ERROR"] ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UnsupportedPathError"](path) : e;
        }
        if (pathErrorCheckOnly) {
            continue;
        }
        handlerData[j] = handlers.map(([h, paramCount])=>{
            const paramIndexMap = /* @__PURE__ */ Object.create(null);
            paramCount -= 1;
            for(; paramCount >= 0; paramCount--){
                const [key, value] = paramAssoc[paramCount];
                paramIndexMap[key] = value;
            }
            return [
                h,
                paramIndexMap
            ];
        });
    }
    const [regexp, indexReplacementMap, paramReplacementMap] = trie.buildRegExp();
    for(let i = 0, len = handlerData.length; i < len; i++){
        for(let j = 0, len2 = handlerData[i].length; j < len2; j++){
            const map = handlerData[i][j]?.[1];
            if (!map) {
                continue;
            }
            const keys = Object.keys(map);
            for(let k = 0, len3 = keys.length; k < len3; k++){
                map[keys[k]] = paramReplacementMap[map[keys[k]]];
            }
        }
    }
    const handlerMap = [];
    for(const i in indexReplacementMap){
        handlerMap[i] = handlerData[indexReplacementMap[i]];
    }
    return [
        regexp,
        handlerMap,
        staticMap
    ];
}
function findMiddleware(middleware, path) {
    if (!middleware) {
        return void 0;
    }
    for (const k of Object.keys(middleware).sort((a, b)=>b.length - a.length)){
        if (buildWildcardRegExp(k).test(path)) {
            return [
                ...middleware[k]
            ];
        }
    }
    return void 0;
}
var RegExpRouter = class {
    name = "RegExpRouter";
    #middleware;
    #routes;
    constructor(){
        this.#middleware = {
            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["METHOD_NAME_ALL"]]: /* @__PURE__ */ Object.create(null)
        };
        this.#routes = {
            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["METHOD_NAME_ALL"]]: /* @__PURE__ */ Object.create(null)
        };
    }
    add(method, path, handler) {
        const middleware = this.#middleware;
        const routes = this.#routes;
        if (!middleware || !routes) {
            throw new Error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MESSAGE_MATCHER_IS_ALREADY_BUILT"]);
        }
        if (!middleware[method]) {
            ;
            [
                middleware,
                routes
            ].forEach((handlerMap)=>{
                handlerMap[method] = /* @__PURE__ */ Object.create(null);
                Object.keys(handlerMap[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["METHOD_NAME_ALL"]]).forEach((p)=>{
                    handlerMap[method][p] = [
                        ...handlerMap[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["METHOD_NAME_ALL"]][p]
                    ];
                });
            });
        }
        if (path === "/*") {
            path = "*";
        }
        const paramCount = (path.match(/\/:/g) || []).length;
        if (/\*$/.test(path)) {
            const re = buildWildcardRegExp(path);
            if (method === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["METHOD_NAME_ALL"]) {
                Object.keys(middleware).forEach((m)=>{
                    middleware[m][path] ||= findMiddleware(middleware[m], path) || findMiddleware(middleware[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["METHOD_NAME_ALL"]], path) || [];
                });
            } else {
                middleware[method][path] ||= findMiddleware(middleware[method], path) || findMiddleware(middleware[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["METHOD_NAME_ALL"]], path) || [];
            }
            Object.keys(middleware).forEach((m)=>{
                if (method === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["METHOD_NAME_ALL"] || method === m) {
                    Object.keys(middleware[m]).forEach((p)=>{
                        re.test(p) && middleware[m][p].push([
                            handler,
                            paramCount
                        ]);
                    });
                }
            });
            Object.keys(routes).forEach((m)=>{
                if (method === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["METHOD_NAME_ALL"] || method === m) {
                    Object.keys(routes[m]).forEach((p)=>re.test(p) && routes[m][p].push([
                            handler,
                            paramCount
                        ]));
                }
            });
            return;
        }
        const paths = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$url$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["checkOptionalParameter"])(path) || [
            path
        ];
        for(let i = 0, len = paths.length; i < len; i++){
            const path2 = paths[i];
            Object.keys(routes).forEach((m)=>{
                if (method === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["METHOD_NAME_ALL"] || method === m) {
                    routes[m][path2] ||= [
                        ...findMiddleware(middleware[m], path2) || findMiddleware(middleware[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["METHOD_NAME_ALL"]], path2) || []
                    ];
                    routes[m][path2].push([
                        handler,
                        paramCount - len + i + 1
                    ]);
                }
            });
        }
    }
    match = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2f$reg$2d$exp$2d$router$2f$matcher$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["match"];
    buildAllMatchers() {
        const matchers = /* @__PURE__ */ Object.create(null);
        Object.keys(this.#routes).concat(Object.keys(this.#middleware)).forEach((method)=>{
            matchers[method] ||= this.#buildMatcher(method);
        });
        this.#middleware = this.#routes = void 0;
        clearWildcardRegExpCache();
        return matchers;
    }
    #buildMatcher(method) {
        const routes = [];
        let hasOwnRoute = method === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["METHOD_NAME_ALL"];
        [
            this.#middleware,
            this.#routes
        ].forEach((r)=>{
            const ownRoute = r[method] ? Object.keys(r[method]).map((path)=>[
                    path,
                    r[method][path]
                ]) : [];
            if (ownRoute.length !== 0) {
                hasOwnRoute ||= true;
                routes.push(...ownRoute);
            } else if (method !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["METHOD_NAME_ALL"]) {
                routes.push(...Object.keys(r[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["METHOD_NAME_ALL"]]).map((path)=>[
                        path,
                        r[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["METHOD_NAME_ALL"]][path]
                    ]));
            }
        });
        if (!hasOwnRoute) {
            return null;
        } else {
            return buildMatcherFromPreprocessedRoutes(routes);
        }
    }
};
;
}),
"[project]/node_modules/hono/dist/router/reg-exp-router/prepared-router.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/router/reg-exp-router/prepared-router.ts
__turbopack_context__.s([
    "PreparedRegExpRouter",
    ()=>PreparedRegExpRouter,
    "buildInitParams",
    ()=>buildInitParams,
    "serializeInitParams",
    ()=>serializeInitParams
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/router.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2f$reg$2d$exp$2d$router$2f$matcher$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/router/reg-exp-router/matcher.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2f$reg$2d$exp$2d$router$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/router/reg-exp-router/router.js [app-route] (ecmascript)");
;
;
;
var PreparedRegExpRouter = class {
    name = "PreparedRegExpRouter";
    #matchers;
    #relocateMap;
    constructor(matchers, relocateMap){
        this.#matchers = matchers;
        this.#relocateMap = relocateMap;
    }
    #addWildcard(method, handlerData) {
        const matcher = this.#matchers[method];
        matcher[1].forEach((list)=>list && list.push(handlerData));
        Object.values(matcher[2]).forEach((list)=>list[0].push(handlerData));
    }
    #addPath(method, path, handler, indexes, map) {
        const matcher = this.#matchers[method];
        if (!map) {
            matcher[2][path][0].push([
                handler,
                {}
            ]);
        } else {
            indexes.forEach((index)=>{
                if (typeof index === "number") {
                    matcher[1][index].push([
                        handler,
                        map
                    ]);
                } else {
                    ;
                    matcher[2][index || path][0].push([
                        handler,
                        map
                    ]);
                }
            });
        }
    }
    add(method, path, handler) {
        if (!this.#matchers[method]) {
            const all = this.#matchers[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["METHOD_NAME_ALL"]];
            const staticMap = {};
            for(const key in all[2]){
                staticMap[key] = [
                    all[2][key][0].slice(),
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2f$reg$2d$exp$2d$router$2f$matcher$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["emptyParam"]
                ];
            }
            this.#matchers[method] = [
                all[0],
                all[1].map((list)=>Array.isArray(list) ? list.slice() : 0),
                staticMap
            ];
        }
        if (path === "/*" || path === "*") {
            const handlerData = [
                handler,
                {}
            ];
            if (method === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["METHOD_NAME_ALL"]) {
                for(const m in this.#matchers){
                    this.#addWildcard(m, handlerData);
                }
            } else {
                this.#addWildcard(method, handlerData);
            }
            return;
        }
        const data = this.#relocateMap[path];
        if (!data) {
            throw new Error(`Path ${path} is not registered`);
        }
        for (const [indexes, map] of data){
            if (method === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["METHOD_NAME_ALL"]) {
                for(const m in this.#matchers){
                    this.#addPath(m, path, handler, indexes, map);
                }
            } else {
                this.#addPath(method, path, handler, indexes, map);
            }
        }
    }
    buildAllMatchers() {
        return this.#matchers;
    }
    match = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2f$reg$2d$exp$2d$router$2f$matcher$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["match"];
};
var buildInitParams = ({ paths })=>{
    const RegExpRouterWithMatcherExport = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2f$reg$2d$exp$2d$router$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RegExpRouter"] {
        buildAndExportAllMatchers() {
            return this.buildAllMatchers();
        }
    };
    const router = new RegExpRouterWithMatcherExport();
    for (const path of paths){
        router.add(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["METHOD_NAME_ALL"], path, path);
    }
    const matchers = router.buildAndExportAllMatchers();
    const all = matchers[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["METHOD_NAME_ALL"]];
    const relocateMap = {};
    for (const path of paths){
        if (path === "/*" || path === "*") {
            continue;
        }
        all[1].forEach((list, i)=>{
            list.forEach(([p, map])=>{
                if (p === path) {
                    if (relocateMap[path]) {
                        relocateMap[path][0][1] = {
                            ...relocateMap[path][0][1],
                            ...map
                        };
                    } else {
                        relocateMap[path] = [
                            [
                                [],
                                map
                            ]
                        ];
                    }
                    if (relocateMap[path][0][0].findIndex((j)=>j === i) === -1) {
                        relocateMap[path][0][0].push(i);
                    }
                }
            });
        });
        for(const path2 in all[2]){
            all[2][path2][0].forEach(([p])=>{
                if (p === path) {
                    relocateMap[path] ||= [
                        [
                            []
                        ]
                    ];
                    const value = path2 === path ? "" : path2;
                    if (relocateMap[path][0][0].findIndex((v)=>v === value) === -1) {
                        relocateMap[path][0][0].push(value);
                    }
                }
            });
        }
    }
    for(let i = 0, len = all[1].length; i < len; i++){
        all[1][i] = all[1][i] ? [] : 0;
    }
    for(const path in all[2]){
        all[2][path][0] = [];
    }
    return [
        matchers,
        relocateMap
    ];
};
var serializeInitParams = ([matchers, relocateMap])=>{
    const matchersStr = JSON.stringify(matchers, (_, value)=>value instanceof RegExp ? `##${value.toString()}##` : value).replace(/"##(.+?)##"/g, (_, str)=>str.replace(/\\\\/g, "\\"));
    const relocateMapStr = JSON.stringify(relocateMap);
    return `[${matchersStr},${relocateMapStr}]`;
};
;
}),
"[project]/node_modules/hono/dist/router/reg-exp-router/index.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

// src/router/reg-exp-router/index.ts
__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2f$reg$2d$exp$2d$router$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/router/reg-exp-router/router.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2f$reg$2d$exp$2d$router$2f$prepared$2d$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/router/reg-exp-router/prepared-router.js [app-route] (ecmascript)");
;
;
;
}),
"[project]/node_modules/hono/dist/router/smart-router/router.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/router/smart-router/router.ts
__turbopack_context__.s([
    "SmartRouter",
    ()=>SmartRouter
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/router.js [app-route] (ecmascript)");
;
var SmartRouter = class {
    name = "SmartRouter";
    #routers = [];
    #routes = [];
    constructor(init){
        this.#routers = init.routers;
    }
    add(method, path, handler) {
        if (!this.#routes) {
            throw new Error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["MESSAGE_MATCHER_IS_ALREADY_BUILT"]);
        }
        this.#routes.push([
            method,
            path,
            handler
        ]);
    }
    match(method, path) {
        if (!this.#routes) {
            throw new Error("Fatal error");
        }
        const routers = this.#routers;
        const routes = this.#routes;
        const len = routers.length;
        let i = 0;
        let res;
        for(; i < len; i++){
            const router = routers[i];
            try {
                for(let i2 = 0, len2 = routes.length; i2 < len2; i2++){
                    router.add(...routes[i2]);
                }
                res = router.match(method, path);
            } catch (e) {
                if (e instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UnsupportedPathError"]) {
                    continue;
                }
                throw e;
            }
            this.match = router.match.bind(router);
            this.#routers = [
                router
            ];
            this.#routes = void 0;
            break;
        }
        if (i === len) {
            throw new Error("Fatal error");
        }
        this.name = `SmartRouter + ${this.activeRouter.name}`;
        return res;
    }
    get activeRouter() {
        if (this.#routes || this.#routers.length !== 1) {
            throw new Error("No active router has been determined yet.");
        }
        return this.#routers[0];
    }
};
;
}),
"[project]/node_modules/hono/dist/router/smart-router/index.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

// src/router/smart-router/index.ts
__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2f$smart$2d$router$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/router/smart-router/router.js [app-route] (ecmascript)");
;
;
}),
"[project]/node_modules/hono/dist/router/trie-router/node.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/router/trie-router/node.ts
__turbopack_context__.s([
    "Node",
    ()=>Node
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/router.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$url$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/utils/url.js [app-route] (ecmascript)");
;
;
var emptyParams = /* @__PURE__ */ Object.create(null);
var Node = class {
    #methods;
    #children;
    #patterns;
    #order = 0;
    #params = emptyParams;
    constructor(method, handler, children){
        this.#children = children || /* @__PURE__ */ Object.create(null);
        this.#methods = [];
        if (method && handler) {
            const m = /* @__PURE__ */ Object.create(null);
            m[method] = {
                handler,
                possibleKeys: [],
                score: 0
            };
            this.#methods = [
                m
            ];
        }
        this.#patterns = [];
    }
    insert(method, path, handler) {
        this.#order = ++this.#order;
        let curNode = this;
        const parts = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$url$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["splitRoutingPath"])(path);
        const possibleKeys = [];
        for(let i = 0, len = parts.length; i < len; i++){
            const p = parts[i];
            const nextP = parts[i + 1];
            const pattern = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$url$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getPattern"])(p, nextP);
            const key = Array.isArray(pattern) ? pattern[0] : p;
            if (key in curNode.#children) {
                curNode = curNode.#children[key];
                if (pattern) {
                    possibleKeys.push(pattern[1]);
                }
                continue;
            }
            curNode.#children[key] = new Node();
            if (pattern) {
                curNode.#patterns.push(pattern);
                possibleKeys.push(pattern[1]);
            }
            curNode = curNode.#children[key];
        }
        curNode.#methods.push({
            [method]: {
                handler,
                possibleKeys: possibleKeys.filter((v, i, a)=>a.indexOf(v) === i),
                score: this.#order
            }
        });
        return curNode;
    }
    #getHandlerSets(node, method, nodeParams, params) {
        const handlerSets = [];
        for(let i = 0, len = node.#methods.length; i < len; i++){
            const m = node.#methods[i];
            const handlerSet = m[method] || m[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["METHOD_NAME_ALL"]];
            const processedSet = {};
            if (handlerSet !== void 0) {
                handlerSet.params = /* @__PURE__ */ Object.create(null);
                handlerSets.push(handlerSet);
                if (nodeParams !== emptyParams || params && params !== emptyParams) {
                    for(let i2 = 0, len2 = handlerSet.possibleKeys.length; i2 < len2; i2++){
                        const key = handlerSet.possibleKeys[i2];
                        const processed = processedSet[handlerSet.score];
                        handlerSet.params[key] = params?.[key] && !processed ? params[key] : nodeParams[key] ?? params?.[key];
                        processedSet[handlerSet.score] = true;
                    }
                }
            }
        }
        return handlerSets;
    }
    search(method, path) {
        const handlerSets = [];
        this.#params = emptyParams;
        const curNode = this;
        let curNodes = [
            curNode
        ];
        const parts = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$url$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["splitPath"])(path);
        const curNodesQueue = [];
        for(let i = 0, len = parts.length; i < len; i++){
            const part = parts[i];
            const isLast = i === len - 1;
            const tempNodes = [];
            for(let j = 0, len2 = curNodes.length; j < len2; j++){
                const node = curNodes[j];
                const nextNode = node.#children[part];
                if (nextNode) {
                    nextNode.#params = node.#params;
                    if (isLast) {
                        if (nextNode.#children["*"]) {
                            handlerSets.push(...this.#getHandlerSets(nextNode.#children["*"], method, node.#params));
                        }
                        handlerSets.push(...this.#getHandlerSets(nextNode, method, node.#params));
                    } else {
                        tempNodes.push(nextNode);
                    }
                }
                for(let k = 0, len3 = node.#patterns.length; k < len3; k++){
                    const pattern = node.#patterns[k];
                    const params = node.#params === emptyParams ? {} : {
                        ...node.#params
                    };
                    if (pattern === "*") {
                        const astNode = node.#children["*"];
                        if (astNode) {
                            handlerSets.push(...this.#getHandlerSets(astNode, method, node.#params));
                            astNode.#params = params;
                            tempNodes.push(astNode);
                        }
                        continue;
                    }
                    const [key, name, matcher] = pattern;
                    if (!part && !(matcher instanceof RegExp)) {
                        continue;
                    }
                    const child = node.#children[key];
                    const restPathString = parts.slice(i).join("/");
                    if (matcher instanceof RegExp) {
                        const m = matcher.exec(restPathString);
                        if (m) {
                            params[name] = m[0];
                            handlerSets.push(...this.#getHandlerSets(child, method, node.#params, params));
                            if (Object.keys(child.#children).length) {
                                child.#params = params;
                                const componentCount = m[0].match(/\//)?.length ?? 0;
                                const targetCurNodes = curNodesQueue[componentCount] ||= [];
                                targetCurNodes.push(child);
                            }
                            continue;
                        }
                    }
                    if (matcher === true || matcher.test(part)) {
                        params[name] = part;
                        if (isLast) {
                            handlerSets.push(...this.#getHandlerSets(child, method, params, node.#params));
                            if (child.#children["*"]) {
                                handlerSets.push(...this.#getHandlerSets(child.#children["*"], method, params, node.#params));
                            }
                        } else {
                            child.#params = params;
                            tempNodes.push(child);
                        }
                    }
                }
            }
            curNodes = tempNodes.concat(curNodesQueue.shift() ?? []);
        }
        if (handlerSets.length > 1) {
            handlerSets.sort((a, b)=>{
                return a.score - b.score;
            });
        }
        return [
            handlerSets.map(({ handler, params })=>[
                    handler,
                    params
                ])
        ];
    }
};
;
}),
"[project]/node_modules/hono/dist/router/trie-router/router.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/router/trie-router/router.ts
__turbopack_context__.s([
    "TrieRouter",
    ()=>TrieRouter
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$url$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/utils/url.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2f$trie$2d$router$2f$node$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/router/trie-router/node.js [app-route] (ecmascript)");
;
;
var TrieRouter = class {
    name = "TrieRouter";
    #node;
    constructor(){
        this.#node = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2f$trie$2d$router$2f$node$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Node"]();
    }
    add(method, path, handler) {
        const results = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$url$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["checkOptionalParameter"])(path);
        if (results) {
            for(let i = 0, len = results.length; i < len; i++){
                this.#node.insert(method, results[i], handler);
            }
            return;
        }
        this.#node.insert(method, path, handler);
    }
    match(method, path) {
        return this.#node.search(method, path);
    }
};
;
}),
"[project]/node_modules/hono/dist/router/trie-router/index.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

// src/router/trie-router/index.ts
__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2f$trie$2d$router$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/router/trie-router/router.js [app-route] (ecmascript)");
;
;
}),
"[project]/node_modules/hono/dist/hono.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/hono.ts
__turbopack_context__.s([
    "Hono",
    ()=>Hono
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$hono$2d$base$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/hono-base.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2f$reg$2d$exp$2d$router$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/router/reg-exp-router/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2f$reg$2d$exp$2d$router$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/router/reg-exp-router/router.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2f$smart$2d$router$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/router/smart-router/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2f$smart$2d$router$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/router/smart-router/router.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2f$trie$2d$router$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/router/trie-router/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2f$trie$2d$router$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/router/trie-router/router.js [app-route] (ecmascript)");
;
;
;
;
var Hono = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$hono$2d$base$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HonoBase"] {
    constructor(options = {}){
        super(options);
        this.router = options.router ?? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2f$smart$2d$router$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SmartRouter"]({
            routers: [
                new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2f$reg$2d$exp$2d$router$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["RegExpRouter"](),
                new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$router$2f$trie$2d$router$2f$router$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TrieRouter"]()
            ]
        });
    }
};
;
}),
"[project]/node_modules/hono/dist/index.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

// src/index.ts
__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$hono$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/hono.js [app-route] (ecmascript)");
;
;
}),
"[project]/node_modules/hono/dist/utils/color.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/utils/color.ts
__turbopack_context__.s([
    "getColorEnabled",
    ()=>getColorEnabled,
    "getColorEnabledAsync",
    ()=>getColorEnabledAsync
]);
function getColorEnabled() {
    const { process, Deno } = globalThis;
    const isNoColor = typeof Deno?.noColor === "boolean" ? Deno.noColor : process !== void 0 ? "NO_COLOR" in process?.env : false;
    return !isNoColor;
}
async function getColorEnabledAsync() {
    const { navigator } = globalThis;
    const cfWorkers = "cloudflare:workers";
    const isNoColor = navigator !== void 0 && navigator.userAgent === "Cloudflare-Workers" ? await (async ()=>{
        try {
            return "NO_COLOR" in ((await Promise.resolve().then(()=>__turbopack_context__.x(cfWorkers, ()=>require(cfWorkers), true))).env ?? {});
        } catch  {
            return false;
        }
    })() : !getColorEnabled();
    return !isNoColor;
}
;
}),
"[project]/node_modules/hono/dist/middleware/logger/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/middleware/logger/index.ts
__turbopack_context__.s([
    "logger",
    ()=>logger
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$color$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/utils/color.js [app-route] (ecmascript)");
;
var humanize = (times)=>{
    const [delimiter, separator] = [
        ",",
        "."
    ];
    const orderTimes = times.map((v)=>v.replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1" + delimiter));
    return orderTimes.join(separator);
};
var time = (start)=>{
    const delta = Date.now() - start;
    return humanize([
        delta < 1e3 ? delta + "ms" : Math.round(delta / 1e3) + "s"
    ]);
};
var colorStatus = async (status)=>{
    const colorEnabled = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$color$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getColorEnabledAsync"])();
    if (colorEnabled) {
        switch(status / 100 | 0){
            case 5:
                return `\x1B[31m${status}\x1B[0m`;
            case 4:
                return `\x1B[33m${status}\x1B[0m`;
            case 3:
                return `\x1B[36m${status}\x1B[0m`;
            case 2:
                return `\x1B[32m${status}\x1B[0m`;
        }
    }
    return `${status}`;
};
async function log(fn, prefix, method, path, status = 0, elapsed) {
    const out = prefix === "<--" /* Incoming */  ? `${prefix} ${method} ${path}` : `${prefix} ${method} ${path} ${await colorStatus(status)} ${elapsed}`;
    fn(out);
}
var logger = (fn = console.log)=>{
    return async function logger2(c, next) {
        const { method, url } = c.req;
        const path = url.slice(url.indexOf("/", 8));
        await log(fn, "<--" /* Incoming */ , method, path);
        const start = Date.now();
        await next();
        await log(fn, "-->" /* Outgoing */ , method, path, c.res.status, time(start));
    };
};
;
}),
"[project]/node_modules/hono/dist/middleware/cors/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/middleware/cors/index.ts
__turbopack_context__.s([
    "cors",
    ()=>cors
]);
var cors = (options)=>{
    const defaults = {
        origin: "*",
        allowMethods: [
            "GET",
            "HEAD",
            "PUT",
            "POST",
            "DELETE",
            "PATCH"
        ],
        allowHeaders: [],
        exposeHeaders: []
    };
    const opts = {
        ...defaults,
        ...options
    };
    const findAllowOrigin = ((optsOrigin)=>{
        if (typeof optsOrigin === "string") {
            if (optsOrigin === "*") {
                return ()=>optsOrigin;
            } else {
                return (origin)=>optsOrigin === origin ? origin : null;
            }
        } else if (typeof optsOrigin === "function") {
            return optsOrigin;
        } else {
            return (origin)=>optsOrigin.includes(origin) ? origin : null;
        }
    })(opts.origin);
    const findAllowMethods = ((optsAllowMethods)=>{
        if (typeof optsAllowMethods === "function") {
            return optsAllowMethods;
        } else if (Array.isArray(optsAllowMethods)) {
            return ()=>optsAllowMethods;
        } else {
            return ()=>[];
        }
    })(opts.allowMethods);
    return async function cors2(c, next) {
        function set(key, value) {
            c.res.headers.set(key, value);
        }
        const allowOrigin = await findAllowOrigin(c.req.header("origin") || "", c);
        if (allowOrigin) {
            set("Access-Control-Allow-Origin", allowOrigin);
        }
        if (opts.credentials) {
            set("Access-Control-Allow-Credentials", "true");
        }
        if (opts.exposeHeaders?.length) {
            set("Access-Control-Expose-Headers", opts.exposeHeaders.join(","));
        }
        if (c.req.method === "OPTIONS") {
            if (opts.origin !== "*") {
                set("Vary", "Origin");
            }
            if (opts.maxAge != null) {
                set("Access-Control-Max-Age", opts.maxAge.toString());
            }
            const allowMethods = await findAllowMethods(c.req.header("origin") || "", c);
            if (allowMethods.length) {
                set("Access-Control-Allow-Methods", allowMethods.join(","));
            }
            let headers = opts.allowHeaders;
            if (!headers?.length) {
                const requestHeaders = c.req.header("Access-Control-Request-Headers");
                if (requestHeaders) {
                    headers = requestHeaders.split(/\s*,\s*/);
                }
            }
            if (headers?.length) {
                set("Access-Control-Allow-Headers", headers.join(","));
                c.res.headers.append("Vary", "Access-Control-Request-Headers");
            }
            c.res.headers.delete("Content-Length");
            c.res.headers.delete("Content-Type");
            return new Response(null, {
                headers: c.res.headers,
                status: 204,
                statusText: "No Content"
            });
        }
        await next();
        if (opts.origin !== "*") {
            c.header("Vary", "Origin", {
                append: true
            });
        }
    };
};
;
}),
"[project]/node_modules/hono/dist/middleware/pretty-json/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/middleware/pretty-json/index.ts
__turbopack_context__.s([
    "prettyJSON",
    ()=>prettyJSON
]);
var prettyJSON = (options)=>{
    const targetQuery = options?.query ?? "pretty";
    return async function prettyJSON2(c, next) {
        const pretty = c.req.query(targetQuery) || c.req.query(targetQuery) === "";
        await next();
        if (pretty && c.res.headers.get("Content-Type")?.startsWith("application/json")) {
            const obj = await c.res.json();
            c.res = new Response(JSON.stringify(obj, null, options?.space ?? 2), c.res);
        }
    };
};
;
}),
"[project]/node_modules/hono/dist/utils/encode.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/utils/encode.ts
__turbopack_context__.s([
    "decodeBase64",
    ()=>decodeBase64,
    "decodeBase64Url",
    ()=>decodeBase64Url,
    "encodeBase64",
    ()=>encodeBase64,
    "encodeBase64Url",
    ()=>encodeBase64Url
]);
var decodeBase64Url = (str)=>{
    return decodeBase64(str.replace(/_|-/g, (m)=>({
            _: "/",
            "-": "+"
        })[m] ?? m));
};
var encodeBase64Url = (buf)=>encodeBase64(buf).replace(/\/|\+/g, (m)=>({
            "/": "_",
            "+": "-"
        })[m] ?? m);
var encodeBase64 = (buf)=>{
    let binary = "";
    const bytes = new Uint8Array(buf);
    for(let i = 0, len = bytes.length; i < len; i++){
        binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
};
var decodeBase64 = (str)=>{
    const binary = atob(str);
    const bytes = new Uint8Array(new ArrayBuffer(binary.length));
    const half = binary.length / 2;
    for(let i = 0, j = binary.length - 1; i <= half; i++, j--){
        bytes[i] = binary.charCodeAt(i);
        bytes[j] = binary.charCodeAt(j);
    }
    return bytes;
};
;
}),
"[project]/node_modules/hono/dist/middleware/secure-headers/secure-headers.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/middleware/secure-headers/secure-headers.ts
__turbopack_context__.s([
    "NONCE",
    ()=>NONCE,
    "secureHeaders",
    ()=>secureHeaders
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$encode$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/utils/encode.js [app-route] (ecmascript)");
;
var HEADERS_MAP = {
    crossOriginEmbedderPolicy: [
        "Cross-Origin-Embedder-Policy",
        "require-corp"
    ],
    crossOriginResourcePolicy: [
        "Cross-Origin-Resource-Policy",
        "same-origin"
    ],
    crossOriginOpenerPolicy: [
        "Cross-Origin-Opener-Policy",
        "same-origin"
    ],
    originAgentCluster: [
        "Origin-Agent-Cluster",
        "?1"
    ],
    referrerPolicy: [
        "Referrer-Policy",
        "no-referrer"
    ],
    strictTransportSecurity: [
        "Strict-Transport-Security",
        "max-age=15552000; includeSubDomains"
    ],
    xContentTypeOptions: [
        "X-Content-Type-Options",
        "nosniff"
    ],
    xDnsPrefetchControl: [
        "X-DNS-Prefetch-Control",
        "off"
    ],
    xDownloadOptions: [
        "X-Download-Options",
        "noopen"
    ],
    xFrameOptions: [
        "X-Frame-Options",
        "SAMEORIGIN"
    ],
    xPermittedCrossDomainPolicies: [
        "X-Permitted-Cross-Domain-Policies",
        "none"
    ],
    xXssProtection: [
        "X-XSS-Protection",
        "0"
    ]
};
var DEFAULT_OPTIONS = {
    crossOriginEmbedderPolicy: false,
    crossOriginResourcePolicy: true,
    crossOriginOpenerPolicy: true,
    originAgentCluster: true,
    referrerPolicy: true,
    strictTransportSecurity: true,
    xContentTypeOptions: true,
    xDnsPrefetchControl: true,
    xDownloadOptions: true,
    xFrameOptions: true,
    xPermittedCrossDomainPolicies: true,
    xXssProtection: true,
    removePoweredBy: true,
    permissionsPolicy: {}
};
var generateNonce = ()=>{
    const arrayBuffer = new Uint8Array(16);
    crypto.getRandomValues(arrayBuffer);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$encode$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["encodeBase64"])(arrayBuffer.buffer);
};
var NONCE = (ctx)=>{
    const key = "secureHeadersNonce";
    const init = ctx.get(key);
    const nonce = init || generateNonce();
    if (init == null) {
        ctx.set(key, nonce);
    }
    return `'nonce-${nonce}'`;
};
var secureHeaders = (customOptions)=>{
    const options = {
        ...DEFAULT_OPTIONS,
        ...customOptions
    };
    const headersToSet = getFilteredHeaders(options);
    const callbacks = [];
    if (options.contentSecurityPolicy) {
        const [callback, value] = getCSPDirectives(options.contentSecurityPolicy);
        if (callback) {
            callbacks.push(callback);
        }
        headersToSet.push([
            "Content-Security-Policy",
            value
        ]);
    }
    if (options.contentSecurityPolicyReportOnly) {
        const [callback, value] = getCSPDirectives(options.contentSecurityPolicyReportOnly);
        if (callback) {
            callbacks.push(callback);
        }
        headersToSet.push([
            "Content-Security-Policy-Report-Only",
            value
        ]);
    }
    if (options.permissionsPolicy && Object.keys(options.permissionsPolicy).length > 0) {
        headersToSet.push([
            "Permissions-Policy",
            getPermissionsPolicyDirectives(options.permissionsPolicy)
        ]);
    }
    if (options.reportingEndpoints) {
        headersToSet.push([
            "Reporting-Endpoints",
            getReportingEndpoints(options.reportingEndpoints)
        ]);
    }
    if (options.reportTo) {
        headersToSet.push([
            "Report-To",
            getReportToOptions(options.reportTo)
        ]);
    }
    return async function secureHeaders2(ctx, next) {
        const headersToSetForReq = callbacks.length === 0 ? headersToSet : callbacks.reduce((acc, cb)=>cb(ctx, acc), headersToSet);
        await next();
        setHeaders(ctx, headersToSetForReq);
        if (options?.removePoweredBy) {
            ctx.res.headers.delete("X-Powered-By");
        }
    };
};
function getFilteredHeaders(options) {
    return Object.entries(HEADERS_MAP).filter(([key])=>options[key]).map(([key, defaultValue])=>{
        const overrideValue = options[key];
        return typeof overrideValue === "string" ? [
            defaultValue[0],
            overrideValue
        ] : defaultValue;
    });
}
function getCSPDirectives(contentSecurityPolicy) {
    const callbacks = [];
    const resultValues = [];
    for (const [directive, value] of Object.entries(contentSecurityPolicy)){
        const valueArray = Array.isArray(value) ? value : [
            value
        ];
        valueArray.forEach((value2, i)=>{
            if (typeof value2 === "function") {
                const index = i * 2 + 2 + resultValues.length;
                callbacks.push((ctx, values)=>{
                    values[index] = value2(ctx, directive);
                });
            }
        });
        resultValues.push(directive.replace(/[A-Z]+(?![a-z])|[A-Z]/g, (match, offset)=>offset ? "-" + match.toLowerCase() : match.toLowerCase()), ...valueArray.flatMap((value2)=>[
                " ",
                value2
            ]), "; ");
    }
    resultValues.pop();
    return callbacks.length === 0 ? [
        void 0,
        resultValues.join("")
    ] : [
        (ctx, headersToSet)=>headersToSet.map((values)=>{
                if (values[0] === "Content-Security-Policy" || values[0] === "Content-Security-Policy-Report-Only") {
                    const clone = values[1].slice();
                    callbacks.forEach((cb)=>{
                        cb(ctx, clone);
                    });
                    return [
                        values[0],
                        clone.join("")
                    ];
                } else {
                    return values;
                }
            }),
        resultValues
    ];
}
function getPermissionsPolicyDirectives(policy) {
    return Object.entries(policy).map(([directive, value])=>{
        const kebabDirective = camelToKebab(directive);
        if (typeof value === "boolean") {
            return `${kebabDirective}=${value ? "*" : "none"}`;
        }
        if (Array.isArray(value)) {
            if (value.length === 0) {
                return `${kebabDirective}=()`;
            }
            if (value.length === 1 && (value[0] === "*" || value[0] === "none")) {
                return `${kebabDirective}=${value[0]}`;
            }
            const allowlist = value.map((item)=>[
                    "self",
                    "src"
                ].includes(item) ? item : `"${item}"`);
            return `${kebabDirective}=(${allowlist.join(" ")})`;
        }
        return "";
    }).filter(Boolean).join(", ");
}
function camelToKebab(str) {
    return str.replace(/([a-z\d])([A-Z])/g, "$1-$2").toLowerCase();
}
function getReportingEndpoints(reportingEndpoints = []) {
    return reportingEndpoints.map((endpoint)=>`${endpoint.name}="${endpoint.url}"`).join(", ");
}
function getReportToOptions(reportTo = []) {
    return reportTo.map((option)=>JSON.stringify(option)).join(", ");
}
function setHeaders(ctx, headersToSet) {
    headersToSet.forEach(([header, value])=>{
        ctx.res.headers.set(header, value);
    });
}
;
}),
"[project]/node_modules/hono/dist/middleware/secure-headers/index.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

// src/middleware/secure-headers/index.ts
__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$middleware$2f$secure$2d$headers$2f$secure$2d$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/middleware/secure-headers/secure-headers.js [app-route] (ecmascript)");
;
;
}),
"[project]/node_modules/hono/dist/utils/cookie.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/utils/cookie.ts
__turbopack_context__.s([
    "parse",
    ()=>parse,
    "parseSigned",
    ()=>parseSigned,
    "serialize",
    ()=>serialize,
    "serializeSigned",
    ()=>serializeSigned
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$url$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/utils/url.js [app-route] (ecmascript)");
;
var algorithm = {
    name: "HMAC",
    hash: "SHA-256"
};
var getCryptoKey = async (secret)=>{
    const secretBuf = typeof secret === "string" ? new TextEncoder().encode(secret) : secret;
    return await crypto.subtle.importKey("raw", secretBuf, algorithm, false, [
        "sign",
        "verify"
    ]);
};
var makeSignature = async (value, secret)=>{
    const key = await getCryptoKey(secret);
    const signature = await crypto.subtle.sign(algorithm.name, key, new TextEncoder().encode(value));
    return btoa(String.fromCharCode(...new Uint8Array(signature)));
};
var verifySignature = async (base64Signature, value, secret)=>{
    try {
        const signatureBinStr = atob(base64Signature);
        const signature = new Uint8Array(signatureBinStr.length);
        for(let i = 0, len = signatureBinStr.length; i < len; i++){
            signature[i] = signatureBinStr.charCodeAt(i);
        }
        return await crypto.subtle.verify(algorithm, secret, signature, new TextEncoder().encode(value));
    } catch  {
        return false;
    }
};
var validCookieNameRegEx = /^[\w!#$%&'*.^`|~+-]+$/;
var validCookieValueRegEx = /^[ !#-:<-[\]-~]*$/;
var parse = (cookie, name)=>{
    if (name && cookie.indexOf(name) === -1) {
        return {};
    }
    const pairs = cookie.trim().split(";");
    const parsedCookie = {};
    for (let pairStr of pairs){
        pairStr = pairStr.trim();
        const valueStartPos = pairStr.indexOf("=");
        if (valueStartPos === -1) {
            continue;
        }
        const cookieName = pairStr.substring(0, valueStartPos).trim();
        if (name && name !== cookieName || !validCookieNameRegEx.test(cookieName)) {
            continue;
        }
        let cookieValue = pairStr.substring(valueStartPos + 1).trim();
        if (cookieValue.startsWith('"') && cookieValue.endsWith('"')) {
            cookieValue = cookieValue.slice(1, -1);
        }
        if (validCookieValueRegEx.test(cookieValue)) {
            parsedCookie[cookieName] = cookieValue.indexOf("%") !== -1 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$url$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["tryDecode"])(cookieValue, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$url$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["decodeURIComponent_"]) : cookieValue;
            if (name) {
                break;
            }
        }
    }
    return parsedCookie;
};
var parseSigned = async (cookie, secret, name)=>{
    const parsedCookie = {};
    const secretKey = await getCryptoKey(secret);
    for (const [key, value] of Object.entries(parse(cookie, name))){
        const signatureStartPos = value.lastIndexOf(".");
        if (signatureStartPos < 1) {
            continue;
        }
        const signedValue = value.substring(0, signatureStartPos);
        const signature = value.substring(signatureStartPos + 1);
        if (signature.length !== 44 || !signature.endsWith("=")) {
            continue;
        }
        const isVerified = await verifySignature(signature, signedValue, secretKey);
        parsedCookie[key] = isVerified ? signedValue : false;
    }
    return parsedCookie;
};
var _serialize = (name, value, opt = {})=>{
    let cookie = `${name}=${value}`;
    if (name.startsWith("__Secure-") && !opt.secure) {
        throw new Error("__Secure- Cookie must have Secure attributes");
    }
    if (name.startsWith("__Host-")) {
        if (!opt.secure) {
            throw new Error("__Host- Cookie must have Secure attributes");
        }
        if (opt.path !== "/") {
            throw new Error('__Host- Cookie must have Path attributes with "/"');
        }
        if (opt.domain) {
            throw new Error("__Host- Cookie must not have Domain attributes");
        }
    }
    if (opt && typeof opt.maxAge === "number" && opt.maxAge >= 0) {
        if (opt.maxAge > 3456e4) {
            throw new Error("Cookies Max-Age SHOULD NOT be greater than 400 days (34560000 seconds) in duration.");
        }
        cookie += `; Max-Age=${opt.maxAge | 0}`;
    }
    if (opt.domain && opt.prefix !== "host") {
        cookie += `; Domain=${opt.domain}`;
    }
    if (opt.path) {
        cookie += `; Path=${opt.path}`;
    }
    if (opt.expires) {
        if (opt.expires.getTime() - Date.now() > 3456e7) {
            throw new Error("Cookies Expires SHOULD NOT be greater than 400 days (34560000 seconds) in the future.");
        }
        cookie += `; Expires=${opt.expires.toUTCString()}`;
    }
    if (opt.httpOnly) {
        cookie += "; HttpOnly";
    }
    if (opt.secure) {
        cookie += "; Secure";
    }
    if (opt.sameSite) {
        cookie += `; SameSite=${opt.sameSite.charAt(0).toUpperCase() + opt.sameSite.slice(1)}`;
    }
    if (opt.priority) {
        cookie += `; Priority=${opt.priority.charAt(0).toUpperCase() + opt.priority.slice(1)}`;
    }
    if (opt.partitioned) {
        if (!opt.secure) {
            throw new Error("Partitioned Cookie must have Secure attributes");
        }
        cookie += "; Partitioned";
    }
    return cookie;
};
var serialize = (name, value, opt)=>{
    value = encodeURIComponent(value);
    return _serialize(name, value, opt);
};
var serializeSigned = async (name, value, secret, opt = {})=>{
    const signature = await makeSignature(value, secret);
    value = `${value}.${signature}`;
    value = encodeURIComponent(value);
    return _serialize(name, value, opt);
};
;
}),
"[project]/node_modules/hono/dist/helper/cookie/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/helper/cookie/index.ts
__turbopack_context__.s([
    "deleteCookie",
    ()=>deleteCookie,
    "generateCookie",
    ()=>generateCookie,
    "generateSignedCookie",
    ()=>generateSignedCookie,
    "getCookie",
    ()=>getCookie,
    "getSignedCookie",
    ()=>getSignedCookie,
    "setCookie",
    ()=>setCookie,
    "setSignedCookie",
    ()=>setSignedCookie
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$cookie$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/utils/cookie.js [app-route] (ecmascript)");
;
var getCookie = (c, key, prefix)=>{
    const cookie = c.req.raw.headers.get("Cookie");
    if (typeof key === "string") {
        if (!cookie) {
            return void 0;
        }
        let finalKey = key;
        if (prefix === "secure") {
            finalKey = "__Secure-" + key;
        } else if (prefix === "host") {
            finalKey = "__Host-" + key;
        }
        const obj2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$cookie$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parse"])(cookie, finalKey);
        return obj2[finalKey];
    }
    if (!cookie) {
        return {};
    }
    const obj = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$cookie$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parse"])(cookie);
    return obj;
};
var getSignedCookie = async (c, secret, key, prefix)=>{
    const cookie = c.req.raw.headers.get("Cookie");
    if (typeof key === "string") {
        if (!cookie) {
            return void 0;
        }
        let finalKey = key;
        if (prefix === "secure") {
            finalKey = "__Secure-" + key;
        } else if (prefix === "host") {
            finalKey = "__Host-" + key;
        }
        const obj2 = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$cookie$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSigned"])(cookie, secret, finalKey);
        return obj2[finalKey];
    }
    if (!cookie) {
        return {};
    }
    const obj = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$cookie$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parseSigned"])(cookie, secret);
    return obj;
};
var generateCookie = (name, value, opt)=>{
    let cookie;
    if (opt?.prefix === "secure") {
        cookie = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$cookie$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serialize"])("__Secure-" + name, value, {
            path: "/",
            ...opt,
            secure: true
        });
    } else if (opt?.prefix === "host") {
        cookie = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$cookie$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serialize"])("__Host-" + name, value, {
            ...opt,
            path: "/",
            secure: true,
            domain: void 0
        });
    } else {
        cookie = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$cookie$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serialize"])(name, value, {
            path: "/",
            ...opt
        });
    }
    return cookie;
};
var setCookie = (c, name, value, opt)=>{
    const cookie = generateCookie(name, value, opt);
    c.header("Set-Cookie", cookie, {
        append: true
    });
};
var generateSignedCookie = async (name, value, secret, opt)=>{
    let cookie;
    if (opt?.prefix === "secure") {
        cookie = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$cookie$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serializeSigned"])("__Secure-" + name, value, secret, {
            path: "/",
            ...opt,
            secure: true
        });
    } else if (opt?.prefix === "host") {
        cookie = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$cookie$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serializeSigned"])("__Host-" + name, value, secret, {
            ...opt,
            path: "/",
            secure: true,
            domain: void 0
        });
    } else {
        cookie = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$cookie$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serializeSigned"])(name, value, secret, {
            path: "/",
            ...opt
        });
    }
    return cookie;
};
var setSignedCookie = async (c, name, value, secret, opt)=>{
    const cookie = await generateSignedCookie(name, value, secret, opt);
    c.header("set-cookie", cookie, {
        append: true
    });
};
var deleteCookie = (c, name, opt)=>{
    const deletedCookie = getCookie(c, name, opt?.prefix);
    setCookie(c, name, "", {
        ...opt,
        maxAge: 0
    });
    return deletedCookie;
};
;
}),
"[project]/node_modules/hono/dist/utils/jwt/jwa.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/utils/jwt/jwa.ts
__turbopack_context__.s([
    "AlgorithmTypes",
    ()=>AlgorithmTypes
]);
var AlgorithmTypes = /* @__PURE__ */ ((AlgorithmTypes2)=>{
    AlgorithmTypes2["HS256"] = "HS256";
    AlgorithmTypes2["HS384"] = "HS384";
    AlgorithmTypes2["HS512"] = "HS512";
    AlgorithmTypes2["RS256"] = "RS256";
    AlgorithmTypes2["RS384"] = "RS384";
    AlgorithmTypes2["RS512"] = "RS512";
    AlgorithmTypes2["PS256"] = "PS256";
    AlgorithmTypes2["PS384"] = "PS384";
    AlgorithmTypes2["PS512"] = "PS512";
    AlgorithmTypes2["ES256"] = "ES256";
    AlgorithmTypes2["ES384"] = "ES384";
    AlgorithmTypes2["ES512"] = "ES512";
    AlgorithmTypes2["EdDSA"] = "EdDSA";
    return AlgorithmTypes2;
})(AlgorithmTypes || {});
;
}),
"[project]/node_modules/hono/dist/helper/adapter/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/helper/adapter/index.ts
__turbopack_context__.s([
    "checkUserAgentEquals",
    ()=>checkUserAgentEquals,
    "env",
    ()=>env,
    "getRuntimeKey",
    ()=>getRuntimeKey,
    "knownUserAgents",
    ()=>knownUserAgents
]);
var env = (c, runtime)=>{
    const global = globalThis;
    const globalEnv = global?.process?.env;
    runtime ??= getRuntimeKey();
    const runtimeEnvHandlers = {
        bun: ()=>globalEnv,
        node: ()=>globalEnv,
        "edge-light": ()=>globalEnv,
        deno: ()=>{
            return Deno.env.toObject();
        },
        workerd: ()=>c.env,
        fastly: ()=>({}),
        other: ()=>({})
    };
    return runtimeEnvHandlers[runtime]();
};
var knownUserAgents = {
    deno: "Deno",
    bun: "Bun",
    workerd: "Cloudflare-Workers",
    node: "Node.js"
};
var getRuntimeKey = ()=>{
    const global = globalThis;
    const userAgentSupported = typeof navigator !== "undefined" && typeof navigator.userAgent === "string";
    if (userAgentSupported) {
        for (const [runtimeKey, userAgent] of Object.entries(knownUserAgents)){
            if (checkUserAgentEquals(userAgent)) {
                return runtimeKey;
            }
        }
    }
    if (typeof global?.EdgeRuntime === "string") {
        return "edge-light";
    }
    if (global?.fastly !== void 0) {
        return "fastly";
    }
    if (global?.process?.release?.name === "node") {
        return "node";
    }
    return "other";
};
var checkUserAgentEquals = (platform)=>{
    const userAgent = navigator.userAgent;
    return userAgent.startsWith(platform);
};
;
}),
"[project]/node_modules/hono/dist/utils/jwt/types.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/utils/jwt/types.ts
__turbopack_context__.s([
    "CryptoKeyUsage",
    ()=>CryptoKeyUsage,
    "JwtAlgorithmNotImplemented",
    ()=>JwtAlgorithmNotImplemented,
    "JwtHeaderInvalid",
    ()=>JwtHeaderInvalid,
    "JwtHeaderRequiresKid",
    ()=>JwtHeaderRequiresKid,
    "JwtPayloadRequiresAud",
    ()=>JwtPayloadRequiresAud,
    "JwtTokenAudience",
    ()=>JwtTokenAudience,
    "JwtTokenExpired",
    ()=>JwtTokenExpired,
    "JwtTokenInvalid",
    ()=>JwtTokenInvalid,
    "JwtTokenIssuedAt",
    ()=>JwtTokenIssuedAt,
    "JwtTokenIssuer",
    ()=>JwtTokenIssuer,
    "JwtTokenNotBefore",
    ()=>JwtTokenNotBefore,
    "JwtTokenSignatureMismatched",
    ()=>JwtTokenSignatureMismatched
]);
var JwtAlgorithmNotImplemented = class extends Error {
    constructor(alg){
        super(`${alg} is not an implemented algorithm`);
        this.name = "JwtAlgorithmNotImplemented";
    }
};
var JwtTokenInvalid = class extends Error {
    constructor(token){
        super(`invalid JWT token: ${token}`);
        this.name = "JwtTokenInvalid";
    }
};
var JwtTokenNotBefore = class extends Error {
    constructor(token){
        super(`token (${token}) is being used before it's valid`);
        this.name = "JwtTokenNotBefore";
    }
};
var JwtTokenExpired = class extends Error {
    constructor(token){
        super(`token (${token}) expired`);
        this.name = "JwtTokenExpired";
    }
};
var JwtTokenIssuedAt = class extends Error {
    constructor(currentTimestamp, iat){
        super(`Invalid "iat" claim, must be a valid number lower than "${currentTimestamp}" (iat: "${iat}")`);
        this.name = "JwtTokenIssuedAt";
    }
};
var JwtTokenIssuer = class extends Error {
    constructor(expected, iss){
        super(`expected issuer "${expected}", got ${iss ? `"${iss}"` : "none"} `);
        this.name = "JwtTokenIssuer";
    }
};
var JwtHeaderInvalid = class extends Error {
    constructor(header){
        super(`jwt header is invalid: ${JSON.stringify(header)}`);
        this.name = "JwtHeaderInvalid";
    }
};
var JwtHeaderRequiresKid = class extends Error {
    constructor(header){
        super(`required "kid" in jwt header: ${JSON.stringify(header)}`);
        this.name = "JwtHeaderRequiresKid";
    }
};
var JwtTokenSignatureMismatched = class extends Error {
    constructor(token){
        super(`token(${token}) signature mismatched`);
        this.name = "JwtTokenSignatureMismatched";
    }
};
var JwtPayloadRequiresAud = class extends Error {
    constructor(payload){
        super(`required "aud" in jwt payload: ${JSON.stringify(payload)}`);
        this.name = "JwtPayloadRequiresAud";
    }
};
var JwtTokenAudience = class extends Error {
    constructor(expected, aud){
        super(`expected audience "${Array.isArray(expected) ? expected.join(", ") : expected}", got "${aud}"`);
        this.name = "JwtTokenAudience";
    }
};
var CryptoKeyUsage = /* @__PURE__ */ ((CryptoKeyUsage2)=>{
    CryptoKeyUsage2["Encrypt"] = "encrypt";
    CryptoKeyUsage2["Decrypt"] = "decrypt";
    CryptoKeyUsage2["Sign"] = "sign";
    CryptoKeyUsage2["Verify"] = "verify";
    CryptoKeyUsage2["DeriveKey"] = "deriveKey";
    CryptoKeyUsage2["DeriveBits"] = "deriveBits";
    CryptoKeyUsage2["WrapKey"] = "wrapKey";
    CryptoKeyUsage2["UnwrapKey"] = "unwrapKey";
    return CryptoKeyUsage2;
})(CryptoKeyUsage || {});
;
}),
"[project]/node_modules/hono/dist/utils/jwt/utf8.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/utils/jwt/utf8.ts
__turbopack_context__.s([
    "utf8Decoder",
    ()=>utf8Decoder,
    "utf8Encoder",
    ()=>utf8Encoder
]);
var utf8Encoder = new TextEncoder();
var utf8Decoder = new TextDecoder();
;
}),
"[project]/node_modules/hono/dist/utils/jwt/jws.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/utils/jwt/jws.ts
__turbopack_context__.s([
    "signing",
    ()=>signing,
    "verifying",
    ()=>verifying
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$helper$2f$adapter$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/helper/adapter/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$encode$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/utils/encode.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/utils/jwt/types.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$utf8$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/utils/jwt/utf8.js [app-route] (ecmascript)");
;
;
;
;
async function signing(privateKey, alg, data) {
    const algorithm = getKeyAlgorithm(alg);
    const cryptoKey = await importPrivateKey(privateKey, algorithm);
    return await crypto.subtle.sign(algorithm, cryptoKey, data);
}
async function verifying(publicKey, alg, signature, data) {
    const algorithm = getKeyAlgorithm(alg);
    const cryptoKey = await importPublicKey(publicKey, algorithm);
    return await crypto.subtle.verify(algorithm, cryptoKey, signature, data);
}
function pemToBinary(pem) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$encode$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["decodeBase64"])(pem.replace(/-+(BEGIN|END).*/g, "").replace(/\s/g, ""));
}
async function importPrivateKey(key, alg) {
    if (!crypto.subtle || !crypto.subtle.importKey) {
        throw new Error("`crypto.subtle.importKey` is undefined. JWT auth middleware requires it.");
    }
    if (isCryptoKey(key)) {
        if (key.type !== "private" && key.type !== "secret") {
            throw new Error(`unexpected key type: CryptoKey.type is ${key.type}, expected private or secret`);
        }
        return key;
    }
    const usages = [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CryptoKeyUsage"].Sign
    ];
    if (typeof key === "object") {
        return await crypto.subtle.importKey("jwk", key, alg, false, usages);
    }
    if (key.includes("PRIVATE")) {
        return await crypto.subtle.importKey("pkcs8", pemToBinary(key), alg, false, usages);
    }
    return await crypto.subtle.importKey("raw", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$utf8$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["utf8Encoder"].encode(key), alg, false, usages);
}
async function importPublicKey(key, alg) {
    if (!crypto.subtle || !crypto.subtle.importKey) {
        throw new Error("`crypto.subtle.importKey` is undefined. JWT auth middleware requires it.");
    }
    if (isCryptoKey(key)) {
        if (key.type === "public" || key.type === "secret") {
            return key;
        }
        key = await exportPublicJwkFrom(key);
    }
    if (typeof key === "string" && key.includes("PRIVATE")) {
        const privateKey = await crypto.subtle.importKey("pkcs8", pemToBinary(key), alg, true, [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CryptoKeyUsage"].Sign
        ]);
        key = await exportPublicJwkFrom(privateKey);
    }
    const usages = [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CryptoKeyUsage"].Verify
    ];
    if (typeof key === "object") {
        return await crypto.subtle.importKey("jwk", key, alg, false, usages);
    }
    if (key.includes("PUBLIC")) {
        return await crypto.subtle.importKey("spki", pemToBinary(key), alg, false, usages);
    }
    return await crypto.subtle.importKey("raw", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$utf8$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["utf8Encoder"].encode(key), alg, false, usages);
}
async function exportPublicJwkFrom(privateKey) {
    if (privateKey.type !== "private") {
        throw new Error(`unexpected key type: ${privateKey.type}`);
    }
    if (!privateKey.extractable) {
        throw new Error("unexpected private key is unextractable");
    }
    const jwk = await crypto.subtle.exportKey("jwk", privateKey);
    const { kty } = jwk;
    const { alg, e, n } = jwk;
    const { crv, x, y } = jwk;
    return {
        kty,
        alg,
        e,
        n,
        crv,
        x,
        y,
        key_ops: [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CryptoKeyUsage"].Verify
        ]
    };
}
function getKeyAlgorithm(name) {
    switch(name){
        case "HS256":
            return {
                name: "HMAC",
                hash: {
                    name: "SHA-256"
                }
            };
        case "HS384":
            return {
                name: "HMAC",
                hash: {
                    name: "SHA-384"
                }
            };
        case "HS512":
            return {
                name: "HMAC",
                hash: {
                    name: "SHA-512"
                }
            };
        case "RS256":
            return {
                name: "RSASSA-PKCS1-v1_5",
                hash: {
                    name: "SHA-256"
                }
            };
        case "RS384":
            return {
                name: "RSASSA-PKCS1-v1_5",
                hash: {
                    name: "SHA-384"
                }
            };
        case "RS512":
            return {
                name: "RSASSA-PKCS1-v1_5",
                hash: {
                    name: "SHA-512"
                }
            };
        case "PS256":
            return {
                name: "RSA-PSS",
                hash: {
                    name: "SHA-256"
                },
                saltLength: 32
            };
        case "PS384":
            return {
                name: "RSA-PSS",
                hash: {
                    name: "SHA-384"
                },
                saltLength: 48
            };
        case "PS512":
            return {
                name: "RSA-PSS",
                hash: {
                    name: "SHA-512"
                },
                saltLength: 64
            };
        case "ES256":
            return {
                name: "ECDSA",
                hash: {
                    name: "SHA-256"
                },
                namedCurve: "P-256"
            };
        case "ES384":
            return {
                name: "ECDSA",
                hash: {
                    name: "SHA-384"
                },
                namedCurve: "P-384"
            };
        case "ES512":
            return {
                name: "ECDSA",
                hash: {
                    name: "SHA-512"
                },
                namedCurve: "P-521"
            };
        case "EdDSA":
            return {
                name: "Ed25519",
                namedCurve: "Ed25519"
            };
        default:
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["JwtAlgorithmNotImplemented"](name);
    }
}
function isCryptoKey(key) {
    const runtime = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$helper$2f$adapter$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getRuntimeKey"])();
    if (runtime === "node" && !!crypto.webcrypto) {
        return key instanceof crypto.webcrypto.CryptoKey;
    }
    return key instanceof CryptoKey;
}
;
}),
"[project]/node_modules/hono/dist/utils/jwt/jwt.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/utils/jwt/jwt.ts
__turbopack_context__.s([
    "decode",
    ()=>decode,
    "decodeHeader",
    ()=>decodeHeader,
    "isTokenHeader",
    ()=>isTokenHeader,
    "sign",
    ()=>sign,
    "verify",
    ()=>verify,
    "verifyWithJwks",
    ()=>verifyWithJwks
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$encode$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/utils/encode.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$jwa$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/utils/jwt/jwa.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$jws$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/utils/jwt/jws.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/utils/jwt/types.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$utf8$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/utils/jwt/utf8.js [app-route] (ecmascript)");
;
;
;
;
;
var encodeJwtPart = (part)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$encode$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["encodeBase64Url"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$utf8$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["utf8Encoder"].encode(JSON.stringify(part)).buffer).replace(/=/g, "");
var encodeSignaturePart = (buf)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$encode$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["encodeBase64Url"])(buf).replace(/=/g, "");
var decodeJwtPart = (part)=>JSON.parse(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$utf8$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["utf8Decoder"].decode((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$encode$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["decodeBase64Url"])(part)));
function isTokenHeader(obj) {
    if (typeof obj === "object" && obj !== null) {
        const objWithAlg = obj;
        return "alg" in objWithAlg && Object.values(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$jwa$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AlgorithmTypes"]).includes(objWithAlg.alg) && (!("typ" in objWithAlg) || objWithAlg.typ === "JWT");
    }
    return false;
}
var sign = async (payload, privateKey, alg = "HS256")=>{
    const encodedPayload = encodeJwtPart(payload);
    let encodedHeader;
    if (typeof privateKey === "object" && "alg" in privateKey) {
        alg = privateKey.alg;
        encodedHeader = encodeJwtPart({
            alg,
            typ: "JWT",
            kid: privateKey.kid
        });
    } else {
        encodedHeader = encodeJwtPart({
            alg,
            typ: "JWT"
        });
    }
    const partialToken = `${encodedHeader}.${encodedPayload}`;
    const signaturePart = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$jws$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["signing"])(privateKey, alg, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$utf8$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["utf8Encoder"].encode(partialToken));
    const signature = encodeSignaturePart(signaturePart);
    return `${partialToken}.${signature}`;
};
var verify = async (token, publicKey, algOrOptions)=>{
    const { alg = "HS256", iss, nbf = true, exp = true, iat = true, aud } = typeof algOrOptions === "string" ? {
        alg: algOrOptions
    } : algOrOptions || {};
    const tokenParts = token.split(".");
    if (tokenParts.length !== 3) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["JwtTokenInvalid"](token);
    }
    const { header, payload } = decode(token);
    if (!isTokenHeader(header)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["JwtHeaderInvalid"](header);
    }
    const now = Date.now() / 1e3 | 0;
    if (nbf && payload.nbf && payload.nbf > now) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["JwtTokenNotBefore"](token);
    }
    if (exp && payload.exp && payload.exp <= now) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["JwtTokenExpired"](token);
    }
    if (iat && payload.iat && now < payload.iat) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["JwtTokenIssuedAt"](now, payload.iat);
    }
    if (iss) {
        if (!payload.iss) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["JwtTokenIssuer"](iss, null);
        }
        if (typeof iss === "string" && payload.iss !== iss) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["JwtTokenIssuer"](iss, payload.iss);
        }
        if (iss instanceof RegExp && !iss.test(payload.iss)) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["JwtTokenIssuer"](iss, payload.iss);
        }
    }
    if (aud) {
        if (!payload.aud) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["JwtPayloadRequiresAud"](payload);
        }
        const audiences = Array.isArray(payload.aud) ? payload.aud : [
            payload.aud
        ];
        const matched = audiences.some((payloadAud)=>aud instanceof RegExp ? aud.test(payloadAud) : typeof aud === "string" ? payloadAud === aud : Array.isArray(aud) && aud.includes(payloadAud));
        if (!matched) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["JwtTokenAudience"](aud, payload.aud);
        }
    }
    const headerPayload = token.substring(0, token.lastIndexOf("."));
    const verified = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$jws$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["verifying"])(publicKey, alg, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$encode$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["decodeBase64Url"])(tokenParts[2]), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$utf8$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["utf8Encoder"].encode(headerPayload));
    if (!verified) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["JwtTokenSignatureMismatched"](token);
    }
    return payload;
};
var verifyWithJwks = async (token, options, init)=>{
    const verifyOpts = options.verification || {};
    const header = decodeHeader(token);
    if (!isTokenHeader(header)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["JwtHeaderInvalid"](header);
    }
    if (!header.kid) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["JwtHeaderRequiresKid"](header);
    }
    if (options.jwks_uri) {
        const response = await fetch(options.jwks_uri, init);
        if (!response.ok) {
            throw new Error(`failed to fetch JWKS from ${options.jwks_uri}`);
        }
        const data = await response.json();
        if (!data.keys) {
            throw new Error('invalid JWKS response. "keys" field is missing');
        }
        if (!Array.isArray(data.keys)) {
            throw new Error('invalid JWKS response. "keys" field is not an array');
        }
        if (options.keys) {
            options.keys.push(...data.keys);
        } else {
            options.keys = data.keys;
        }
    } else if (!options.keys) {
        throw new Error('verifyWithJwks requires options for either "keys" or "jwks_uri" or both');
    }
    const matchingKey = options.keys.find((key)=>key.kid === header.kid);
    if (!matchingKey) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["JwtTokenInvalid"](token);
    }
    return await verify(token, matchingKey, {
        alg: matchingKey.alg || header.alg,
        ...verifyOpts
    });
};
var decode = (token)=>{
    try {
        const [h, p] = token.split(".");
        const header = decodeJwtPart(h);
        const payload = decodeJwtPart(p);
        return {
            header,
            payload
        };
    } catch  {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["JwtTokenInvalid"](token);
    }
};
var decodeHeader = (token)=>{
    try {
        const [h] = token.split(".");
        return decodeJwtPart(h);
    } catch  {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["JwtTokenInvalid"](token);
    }
};
;
}),
"[project]/node_modules/hono/dist/utils/jwt/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/utils/jwt/index.ts
__turbopack_context__.s([
    "Jwt",
    ()=>Jwt
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$jwt$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/utils/jwt/jwt.js [app-route] (ecmascript)");
;
var Jwt = {
    sign: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$jwt$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["sign"],
    verify: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$jwt$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["verify"],
    decode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$jwt$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["decode"],
    verifyWithJwks: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$jwt$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["verifyWithJwks"]
};
;
}),
"[project]/node_modules/hono/dist/middleware/jwt/jwt.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/middleware/jwt/jwt.ts
__turbopack_context__.s([
    "decode",
    ()=>decode,
    "jwt",
    ()=>jwt,
    "sign",
    ()=>sign,
    "verify",
    ()=>verify,
    "verifyWithJwks",
    ()=>verifyWithJwks
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$helper$2f$cookie$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/helper/cookie/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$http$2d$exception$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/http-exception.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/utils/jwt/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$context$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/context.js [app-route] (ecmascript)");
;
;
;
;
var jwt = (options)=>{
    const verifyOpts = options.verification || {};
    if (!options || !options.secret) {
        throw new Error('JWT auth middleware requires options for "secret"');
    }
    if (!crypto.subtle || !crypto.subtle.importKey) {
        throw new Error("`crypto.subtle.importKey` is undefined. JWT auth middleware requires it.");
    }
    return async function jwt2(ctx, next) {
        const headerName = options.headerName || "Authorization";
        const credentials = ctx.req.raw.headers.get(headerName);
        let token;
        if (credentials) {
            const parts = credentials.split(/\s+/);
            if (parts.length !== 2) {
                const errDescription = "invalid credentials structure";
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$http$2d$exception$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HTTPException"](401, {
                    message: errDescription,
                    res: unauthorizedResponse({
                        ctx,
                        error: "invalid_request",
                        errDescription
                    })
                });
            } else {
                token = parts[1];
            }
        } else if (options.cookie) {
            if (typeof options.cookie == "string") {
                token = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$helper$2f$cookie$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCookie"])(ctx, options.cookie);
            } else if (options.cookie.secret) {
                if (options.cookie.prefixOptions) {
                    token = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$helper$2f$cookie$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getSignedCookie"])(ctx, options.cookie.secret, options.cookie.key, options.cookie.prefixOptions);
                } else {
                    token = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$helper$2f$cookie$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getSignedCookie"])(ctx, options.cookie.secret, options.cookie.key);
                }
            } else {
                if (options.cookie.prefixOptions) {
                    token = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$helper$2f$cookie$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCookie"])(ctx, options.cookie.key, options.cookie.prefixOptions);
                } else {
                    token = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$helper$2f$cookie$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCookie"])(ctx, options.cookie.key);
                }
            }
        }
        if (!token) {
            const errDescription = "no authorization included in request";
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$http$2d$exception$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HTTPException"](401, {
                message: errDescription,
                res: unauthorizedResponse({
                    ctx,
                    error: "invalid_request",
                    errDescription
                })
            });
        }
        let payload;
        let cause;
        try {
            payload = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Jwt"].verify(token, options.secret, {
                alg: options.alg,
                ...verifyOpts
            });
        } catch (e) {
            cause = e;
        }
        if (!payload) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$http$2d$exception$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HTTPException"](401, {
                message: "Unauthorized",
                res: unauthorizedResponse({
                    ctx,
                    error: "invalid_token",
                    statusText: "Unauthorized",
                    errDescription: "token verification failure"
                }),
                cause
            });
        }
        ctx.set("jwtPayload", payload);
        await next();
    };
};
function unauthorizedResponse(opts) {
    return new Response("Unauthorized", {
        status: 401,
        statusText: opts.statusText,
        headers: {
            "WWW-Authenticate": `Bearer realm="${opts.ctx.req.url}",error="${opts.error}",error_description="${opts.errDescription}"`
        }
    });
}
var verifyWithJwks = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Jwt"].verifyWithJwks;
var verify = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Jwt"].verify;
var decode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Jwt"].decode;
var sign = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$jwt$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Jwt"].sign;
;
}),
"[project]/node_modules/hono/dist/middleware/jwt/index.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

// src/middleware/jwt/index.ts
__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$middleware$2f$jwt$2f$jwt$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/middleware/jwt/jwt.js [app-route] (ecmascript)");
;
;
}),
"[project]/node_modules/hono/dist/utils/crypto.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/utils/crypto.ts
__turbopack_context__.s([
    "createHash",
    ()=>createHash,
    "md5",
    ()=>md5,
    "sha1",
    ()=>sha1,
    "sha256",
    ()=>sha256
]);
var sha256 = async (data)=>{
    const algorithm = {
        name: "SHA-256",
        alias: "sha256"
    };
    const hash = await createHash(data, algorithm);
    return hash;
};
var sha1 = async (data)=>{
    const algorithm = {
        name: "SHA-1",
        alias: "sha1"
    };
    const hash = await createHash(data, algorithm);
    return hash;
};
var md5 = async (data)=>{
    const algorithm = {
        name: "MD5",
        alias: "md5"
    };
    const hash = await createHash(data, algorithm);
    return hash;
};
var createHash = async (data, algorithm)=>{
    let sourceBuffer;
    if (ArrayBuffer.isView(data) || data instanceof ArrayBuffer) {
        sourceBuffer = data;
    } else {
        if (typeof data === "object") {
            data = JSON.stringify(data);
        }
        sourceBuffer = new TextEncoder().encode(String(data));
    }
    if (crypto && crypto.subtle) {
        const buffer = await crypto.subtle.digest({
            name: algorithm.name
        }, sourceBuffer);
        const hash = Array.prototype.map.call(new Uint8Array(buffer), (x)=>("00" + x.toString(16)).slice(-2)).join("");
        return hash;
    }
    return null;
};
;
}),
"[project]/node_modules/hono/dist/utils/buffer.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/utils/buffer.ts
__turbopack_context__.s([
    "bufferToFormData",
    ()=>bufferToFormData,
    "bufferToString",
    ()=>bufferToString,
    "equal",
    ()=>equal,
    "timingSafeEqual",
    ()=>timingSafeEqual
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$crypto$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/utils/crypto.js [app-route] (ecmascript)");
;
var equal = (a, b)=>{
    if (a === b) {
        return true;
    }
    if (a.byteLength !== b.byteLength) {
        return false;
    }
    const va = new DataView(a);
    const vb = new DataView(b);
    let i = va.byteLength;
    while(i--){
        if (va.getUint8(i) !== vb.getUint8(i)) {
            return false;
        }
    }
    return true;
};
var timingSafeEqual = async (a, b, hashFunction)=>{
    if (!hashFunction) {
        hashFunction = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$crypto$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["sha256"];
    }
    const [sa, sb] = await Promise.all([
        hashFunction(a),
        hashFunction(b)
    ]);
    if (!sa || !sb) {
        return false;
    }
    return sa === sb && a === b;
};
var bufferToString = (buffer)=>{
    if (buffer instanceof ArrayBuffer) {
        const enc = new TextDecoder("utf-8");
        return enc.decode(buffer);
    }
    return buffer;
};
var bufferToFormData = (arrayBuffer, contentType)=>{
    const response = new Response(arrayBuffer, {
        headers: {
            "Content-Type": contentType
        }
    });
    return response.formData();
};
;
}),
"[project]/node_modules/hono/dist/validator/validator.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/validator/validator.ts
__turbopack_context__.s([
    "validator",
    ()=>validator
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$helper$2f$cookie$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/helper/cookie/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$http$2d$exception$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/http-exception.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$buffer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/utils/buffer.js [app-route] (ecmascript)");
;
;
;
var jsonRegex = /^application\/([a-z-\.]+\+)?json(;\s*[a-zA-Z0-9\-]+\=([^;]+))*$/;
var multipartRegex = /^multipart\/form-data(;\s?boundary=[a-zA-Z0-9'"()+_,\-./:=?]+)?$/;
var urlencodedRegex = /^application\/x-www-form-urlencoded(;\s*[a-zA-Z0-9\-]+\=([^;]+))*$/;
var validator = (target, validationFunc)=>{
    return async (c, next)=>{
        let value = {};
        const contentType = c.req.header("Content-Type");
        switch(target){
            case "json":
                if (!contentType || !jsonRegex.test(contentType)) {
                    break;
                }
                try {
                    value = await c.req.json();
                } catch  {
                    const message = "Malformed JSON in request body";
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$http$2d$exception$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HTTPException"](400, {
                        message
                    });
                }
                break;
            case "form":
                {
                    if (!contentType || !(multipartRegex.test(contentType) || urlencodedRegex.test(contentType))) {
                        break;
                    }
                    let formData;
                    if (c.req.bodyCache.formData) {
                        formData = await c.req.bodyCache.formData;
                    } else {
                        try {
                            const arrayBuffer = await c.req.arrayBuffer();
                            formData = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$utils$2f$buffer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["bufferToFormData"])(arrayBuffer, contentType);
                            c.req.bodyCache.formData = formData;
                        } catch (e) {
                            let message = "Malformed FormData request.";
                            message += e instanceof Error ? ` ${e.message}` : ` ${String(e)}`;
                            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$http$2d$exception$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HTTPException"](400, {
                                message
                            });
                        }
                    }
                    const form = {};
                    formData.forEach((value2, key)=>{
                        if (key.endsWith("[]")) {
                            ;
                            (form[key] ??= []).push(value2);
                        } else if (Array.isArray(form[key])) {
                            ;
                            form[key].push(value2);
                        } else if (key in form) {
                            form[key] = [
                                form[key],
                                value2
                            ];
                        } else {
                            form[key] = value2;
                        }
                    });
                    value = form;
                    break;
                }
            case "query":
                value = Object.fromEntries(Object.entries(c.req.queries()).map(([k, v])=>{
                    return v.length === 1 ? [
                        k,
                        v[0]
                    ] : [
                        k,
                        v
                    ];
                }));
                break;
            case "param":
                value = c.req.param();
                break;
            case "header":
                value = c.req.header();
                break;
            case "cookie":
                value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$helper$2f$cookie$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCookie"])(c);
                break;
        }
        const res = await validationFunc(value, c);
        if (res instanceof Response) {
            return res;
        }
        c.req.addValidatedData(target, res);
        return await next();
    };
};
;
}),
"[project]/node_modules/hono/dist/validator/index.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

// src/validator/index.ts
__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hono$2f$dist$2f$validator$2f$validator$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hono/dist/validator/validator.js [app-route] (ecmascript)");
;
;
}),
];

//# sourceMappingURL=node_modules_hono_dist_2bf8cecc._.js.map